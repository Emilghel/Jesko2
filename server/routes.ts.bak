import type { Express } from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
import bcrypt from "bcrypt";
import { storage } from "./storage";
import { handleTwilioWebhook, endCall, handleRecordingWebhook, handleRecordingStatusWebhook } from "./lib/twilio";
import { getTtsStream } from "./lib/elevenlabs";
import { getOpenAIResponse, chatWithAssistant } from "./lib/openai";
import { generateImageFromText, generateImageFromImageAndText } from "./lib/openai-image-fixed";
import { uploadSingleImage, uploadSingleVideo, uploadSingleClipVideo } from "./lib/multer-config";
import multer from "multer";
import { v4 as uuidv4 } from "uuid";

// Configure multer for image uploads
const upload = multer({
  dest: path.join(process.cwd(), 'uploads'),
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB file size limit
  },
  fileFilter: (_req, file, callback) => {
    // Accept only image files
    if (file.mimetype.startsWith('image/')) {
      callback(null, true);
    } else {
      callback(new Error('Only image files are allowed!'));
    }
  }
});
import { generateClips, mockGenerateClips } from "./lib/spike-api";
import { processVideoForTranscription } from "./direct-whisper";
import jwt from "jsonwebtoken";
import { 
  LogLevel, 
  CallStatus, 
  TransactionType, 
  PartnerStatus,
  ReferralStatus,
  PaymentStatus,
  CommissionStatus,
  InsertPartner,
  InsertPartnerPayment,
  InsertReferral,
  InsertPartnerCommission,
  stockVideos
} from "@shared/schema";
import { sql, eq } from "drizzle-orm";
import stockVideosRouter from "./stock-videos-routes";
import os from "os";
import axios from "axios";
import twilio from "twilio";
import express, { Request, Response, NextFunction } from "express";
import cors from "cors";
import cookieParser from "cookie-parser";
import session from "express-session";
import * as fs from 'fs';
import * as path from 'path';
// No longer need passport and session
import { setupPassport, isAuthenticated, registerUser, loginUser, logoutUser, registerToken, activeTokens } from "./lib/auth-simple";
import { pool, db } from "./db";
import paypalRoutes from "./lib/paypal-routes";
import { testPayPalCredentials } from "./lib/paypal";
import { generateMemberJoinNotification } from "./lib/notification-utils";
import userProfileRoutes from "./user-profile-routes";
import FormData from "form-data";
import fetch from "node-fetch";

// Active WebSocket connections map
const clients = new Map<string, WebSocket>();

// Keep track of conversation contexts
const conversationContexts = new Map<string, any[]>();

// Store the startup time to calculate uptime
const startTime = new Date();

// Timer ID for member counter update interval
let memberCounterTimer: NodeJS.Timeout | null = null;

// Removed Play.ht import in favor of ElevenLabs

// Middleware for checking if a user is a partner
function isPartner(req: Request, res: Response, next: NextFunction) {
  // Check for special tokens in Authorization header
  const authHeader = req.headers.authorization;
  
  // If we have an authorization header with Bearer token, check if it's a special token
  if (authHeader && authHeader.startsWith('Bearer ')) {
    const token = authHeader.substring(7);
    
    // Check for special hard-coded bypass tokens
    if (token === 'admin_bypass_token' || token === 'zach_special_token') {
      console.log(`Special token detected in isPartner middleware: ${token}`);
      
      // Create a mock partner object
      const mockPartner = {
        id: token === 'zach_special_token' ? 9999 : 1,
        user_id: token === 'zach_special_token' ? 9999 : 1,
        company_name: token === 'zach_special_token' ? 'Zach Partner Account' : 'Admin Partner',
        contact_name: token === 'zach_special_token' ? 'Zach' : 'Admin',
        referral_code: token === 'zach_special_token' ? 'ZACH' : 'ADMIN',
        commission_rate: 30,
        earnings_balance: 0,
        total_earnings: 0,
        status: PartnerStatus.ACTIVE,
        created_at: new Date(),
        website: token === 'zach_special_token' ? 'https://zachwarmleadnetwork.com' : 'https://warmleadnetwork.com',
        bio: token === 'zach_special_token' ? 'Special partner account for Zach' : 'Admin partner account'
      };
      
      // Add mock partner to request object
      (req as any).partner = mockPartner;
      
      // Log access
      console.log(`Partner access granted via special token: ${token === 'zach_special_token' ? 'Zach' : 'Admin'}`);
      
      // Continue
      return next();
    }
  }
  
  // Normal authentication flow
  if (!req.isAuthenticated()) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  // Check if the user is a partner
  storage.getPartnerByUserId(req.user!.id)
    .then(partner => {
      if (!partner) {
        return res.status(403).json({ error: 'Access forbidden - User is not a partner' });
      }
      
      // Add partner to request object for ease of access
      (req as any).partner = partner;
      next();
    })
    .catch(error => {
      console.error('Error in isPartner middleware:', error);
      res.status(500).json({ error: 'Internal server error' });
    });
}

// Middleware to check if a user is an admin (and not a partner)
function isAdmin(req: Request, res: Response, next: NextFunction) {
  // Check if request has a partnerToken - if so, block access regardless of admin status
  const partnerToken = req.headers.authorization?.startsWith('Bearer ') 
    ? req.headers.authorization.substring(7) 
    : req.cookies?.partnerToken;
  
  if (partnerToken === 'zach_special_token' || partnerToken?.startsWith('admin_setup_token_') || partnerToken === 'admin_bypass_token') {
    return res.status(403).json({ error: 'Access forbidden - Partner accounts cannot access admin resources' });
  }

  // Check authentication
  if (!req.isAuthenticated()) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  // Check admin status
  if (!(req.user as any).isAdmin) {
    return res.status(403).json({ error: 'Access forbidden - Admin privileges required' });
  }

  // Explicitly check that the user is not also a partner
  storage.getPartnerByUserId(req.user.id)
    .then(partner => {
      if (partner) {
        // If user is both admin and partner, block admin access when using partner authentication
        return res.status(403).json({ error: 'Access forbidden - Cannot access admin resources when authenticated as a partner' });
      }
      // User is admin and not partner, allow access
      next();
    })
    .catch(error => {
      console.error('Error in isAdmin middleware:', error);
      res.status(500).json({ error: 'Internal server error' });
    });
}

// Helper function to generate a unique referral code
function generateReferralCode(companyName: string): string {
  const cleanName = companyName
    .replace(/[^a-zA-Z0-9]/g, '') // Remove special characters
    .substring(0, 8) // Take first 8 chars
    .toUpperCase();
    
  const randomStr = Math.random().toString(36).substring(2, 6).toUpperCase();
  return `${cleanName}-${randomStr}`;
}

export async function registerRoutes(app: Express): Promise<Server> {
  const httpServer = createServer(app);
  
  // Check if this is the production deployment URL
  const isProductionDeploy = process.env.REPL_SLUG === 'node-ninja-emilghelmeci';
  console.log(`Detected environment: ${isProductionDeploy ? 'Production Deployment' : 'Development'}`);
  
  // Initialize our token-based auth system
  setupPassport();
  
  // Initialize Twilio client
  const twilioClient = twilio(
    process.env.TWILIO_ACCOUNT_SID,
    process.env.TWILIO_AUTH_TOKEN
  );
  
  // Register PayPal routes
  app.use('/api/paypal', paypalRoutes);
  
  // Register User Profile routes
  app.use('/api/user', userProfileRoutes);
  
  // Register Stock Videos routes
  app.use('/api/stock-videos', stockVideosRouter);
  
  // Register Admin Panel routes - temporarily disabled
  // app.use(adminRoutes);
  
  // Serve static files from the temp directory
  // Use path.resolve with process.cwd() instead of __dirname for ES modules
  app.use('/temp', express.static(path.resolve(process.cwd(), 'temp')));
  
  // Initialize and set up the member counter
  const initializeMemberCounter = async () => {
    try {
      // Check if member_count statistic exists
      let memberCount = await storage.getSiteStatistic('member_count');
      
      // If not, create it with a default starting value
      if (!memberCount) {
        memberCount = await storage.createSiteStatistic({
          name: 'member_count',
          value: 2000
        });
        console.log('Created initial member counter with value:', memberCount.value);
      } else {
        console.log('Found existing member counter with value:', memberCount.value);
      }
      
      // Set up the counter update cycle with variable intervals
      const updateMemberCounter = async () => {
        try {
          // Slow down the increment rate by 5x
          // Only increment approximately 20% of the time
          if (Math.random() < 0.2) {
            // Possible increment amounts (smaller amounts for slower counting)
            const increments = [1];
            
            // Randomly select an increment amount
            const incrementAmount = increments[Math.floor(Math.random() * increments.length)];
            
            // Increment the counter
            const updatedCounter = await storage.incrementSiteStatistic('member_count', incrementAmount);
            console.log(`Member counter incremented by ${incrementAmount}, new value:`, updatedCounter?.value);
          
            // Generate member join notifications (one for each increment)
            for (let i = 0; i < incrementAmount; i++) {
              // Generate a random member join notification
              const notification = generateMemberJoinNotification();
              
              // Broadcast the notification to all connected clients
              broadcastToAll({
                type: 'member_join',
                data: notification,
                timestamp: new Date().toISOString()
              });
              
              // Small delay between multiple notifications if there are more than one
              if (i < incrementAmount - 1) {
                await new Promise(resolve => setTimeout(resolve, 500));
              }
            }
          }
          
          // Set a random interval for the next update (between 10-20 seconds)
          const nextInterval = 10000 + Math.floor(Math.random() * 10000);
          
          // Schedule the next update
          memberCounterTimer = setTimeout(updateMemberCounter, nextInterval);
        } catch (error) {
          console.error('Error updating member counter:', error);
          // Try again in 30 seconds if there was an error
          memberCounterTimer = setTimeout(updateMemberCounter, 30000);
        }
      };
      
      // Start the first update cycle
      updateMemberCounter();
      
    } catch (error) {
      console.error('Error initializing member counter:', error);
    }
  };
  
  // Start the member counter
  initializeMemberCounter();
  
  // Endpoint to get the current member count
  app.get('/api/stats/member-count', async (req, res) => {
    try {
      const memberCount = await storage.getSiteStatistic('member_count');
      
      if (!memberCount) {
        return res.status(404).json({ error: 'Member count not found' });
      }
      
      res.json({ 
        count: memberCount.value,
        lastUpdated: memberCount.last_updated
      });
    } catch (error) {
      console.error('Error getting member count:', error);
      res.status(500).json({ error: 'Failed to retrieve member count' });
    }
  });
  
  // Get user's purchased phone numbers
  app.get('/api/user/phone-numbers', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      const phoneNumbers = await storage.getPurchasedPhoneNumbers(user.id);
      res.json(phoneNumbers);
    } catch (error) {
      console.error("Error getting user's phone numbers:", error);
      res.status(500).json({ error: "Failed to retrieve phone numbers" });
    }
  });
  
  // Get user's coin balance
  app.get('/api/user/coins', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      const coins = await storage.getUserCoins(user.id);
      res.json({ coins });
    } catch (error) {
      console.error("Error getting user's coin balance:", error);
      res.status(500).json({ error: "Failed to retrieve coin balance" });
    }
  });
  
  // Update user's profession
  app.post('/api/user/update-profession', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      const { profession } = req.body;
      
      if (!profession) {
        return res.status(400).json({ error: 'Profession is required' });
      }
      
      // Update the user's profession
      const updatedUser = await storage.updateUserProfession(user.id, profession);
      
      if (!updatedUser) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      await logMessage(LogLevel.INFO, 'User', `User ${user.email} updated profession to: ${profession}`);
      
      res.status(200).json({ 
        success: true,
        message: 'Profession updated successfully',
        profession
      });
    } catch (error) {
      console.error('Error updating user profession:', error);
      res.status(500).json({ error: 'Failed to update profession' });
    }
  });
  
  // Special endpoint to add 1 million coins to a user (temporary endpoint)
  app.post('/api/admin/add-million-coins', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ error: 'Email is required' });
      }
      
      // Find the user by email
      const userQuery = await pool.query('SELECT id, email FROM users WHERE email = $1', [email]);
      
      if (userQuery.rows.length === 0) {
        return res.status(404).json({ error: `User with email ${email} not found` });
      }
      
      const targetUser = userQuery.rows[0];
      const coinAmount = 1000000; // One million coins
      
      // Add the coins to the user's account
      const newCoinsBalance = await storage.addUserCoins(
        targetUser.id,
        coinAmount,
        'ADMIN_GIFT',
        `Special gift of 1 million coins to ${targetUser.email}`,
      );
      
      // Log the action
      await logMessage(LogLevel.INFO, 'Admin', `Added 1 million coins to user ${targetUser.email}`);
      
      res.json({ 
        success: true, 
        message: `Successfully added ${coinAmount} coins to ${targetUser.email}`,
        user: targetUser.email,
        newBalance: newCoinsBalance
      });
    } catch (error) {
      console.error("Error adding coins to user:", error);
      res.status(500).json({ error: "Failed to add coins to user", details: error instanceof Error ? error.message : String(error) });
    }
  });
  
  // Get user's coin transaction history
  app.get('/api/user/coins/transactions', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 100;
      const transactions = await storage.getCoinTransactions(user.id, limit);
      res.json(transactions);
    } catch (error) {
      console.error("Error getting user's coin transactions:", error);
      res.status(500).json({ error: "Failed to retrieve coin transactions" });
    }
  });
  
  // Character selection endpoint
  // Get the user's current profession
  app.get('/api/user/character-selection', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      // Get the latest user data to ensure we have the current profession
      const currentUser = await storage.getUser(user.id);
      
      if (!currentUser) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.status(200).json({ 
        profession: currentUser.profession || null 
      });
    } catch (error) {
      console.error('Error getting character selection:', error);
      res.status(500).json({ error: 'Failed to get character selection' });
    }
  });

  // Set the user's profession choice
  app.post('/api/user/character-selection', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      const { profession } = req.body;
      
      if (!profession) {
        return res.status(400).json({ error: 'Profession selection is required' });
      }
      
      // Validate profession
      const validProfessions = [
        'real-estate', 'ecommerce', 'content-creator', 'law-firm', 
        'marketing-agency', 'insurance', 'crypto', 'event-planner'
      ];
      
      if (!validProfessions.includes(profession)) {
        return res.status(400).json({ error: 'Invalid profession selection' });
      }
      
      // Save the user's profession selection
      await storage.updateUserProfession(user.id, profession);
      
      // Log the character selection
      console.log(`Character selection saved for user ${user.id}: ${profession}`);
      
      res.status(200).json({ 
        success: true, 
        message: 'Character selection saved successfully',
        profession
      });
    } catch (error) {
      console.error('Error saving character selection:', error);
      res.status(500).json({ error: 'Failed to save character selection' });
    }
  });
  
  // Buy coins with payment gateway
  app.post('/api/coins/buy', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      const { package_id, payment_id, amount } = req.body;
      
      if (!package_id || !payment_id || !amount || typeof amount !== 'number') {
        return res.status(400).json({ error: 'Invalid request. Required fields: package_id, payment_id, amount' });
      }
      
      // Add coins to user account
      const newBalance = await storage.addUserCoins(
        user.id,
        amount,
        TransactionType.PURCHASE,
        `Purchased ${amount} coins`,
        package_id,
        payment_id
      );
      
      await logMessage(LogLevel.INFO, 'Coins', `User ${user.email} purchased ${amount} coins with payment ${payment_id}`);
      
      res.json({ 
        success: true, 
        coins: newBalance,
        message: `Successfully added ${amount} coins to your account`
      });
    } catch (error) {
      console.error("Error processing coin purchase:", error);
      await logMessage(LogLevel.ERROR, 'Coins', `Error processing coin purchase: ${error instanceof Error ? error.message : String(error)}`);
      res.status(500).json({ error: "Failed to process purchase", details: error instanceof Error ? error.message : String(error) });
    }
  });
  
  // Endpoint for AI voice generation to use coins
  app.post('/api/voiceover/use', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      const { text, voice_id } = req.body;
      
      if (!text || typeof text !== 'string') {
        return res.status(400).json({ error: 'Invalid request. Required field: text' });
      }
      
      // Calculate the cost of generating this text (1 coin per word)
      const wordCount = text.trim().split(/\s+/).length;
      const coinCost = wordCount;
      
      // Check if user has enough coins
      const userCoins = await storage.getUserCoins(user.id);
      
      if (userCoins < coinCost) {
        return res.status(403).json({ 
          error: 'Insufficient coins', 
          required: coinCost, 
          available: userCoins,
          message: `You need ${coinCost} coins to generate this voiceover, but you only have ${userCoins} coins.`
        });
      }
      
      // Process the text-to-speech request with ElevenLabs
      const selectedVoiceId = voice_id || "EXAVITQu4vr4xnSDxMaL"; // Default to Rachel voice if not specified
      
      // Create options object from request body
      const ttsOptions = {
        voiceId: selectedVoiceId,
        stability: req.body.stability || 0.5,
        similarity: req.body.similarity_boost || 0.75,
        style: req.body.style || 0,
        speakerBoost: req.body.speaker_boost || true,
        modelId: req.body.model_id || 'eleven_monolingual_v1',
        voice_speed: req.body.speed || 1.0
      };
      
      try {
        // First deduct coins from the user account
        const deductResult = await storage.deductUserCoins(
          user.id,
          coinCost,
          `Generated voiceover (${wordCount} words)`
        );
        
        if (!deductResult) {
          return res.status(403).json({ error: 'Failed to deduct coins from account' });
        }
        
        // Log the coin deduction
        await logMessage(LogLevel.INFO, 'Coins', `User ${user.email} used ${coinCost} coins for voiceover`);
        
        // Get the coin transaction for this deduction (most recent transaction for this user)
        const transactions = await storage.getCoinTransactions(user.id, 1);
        const coinTransaction = transactions[0];
        
        if (!coinTransaction) {
          throw new Error('Coin transaction not found - this should never happen');
        }
        
        // Now generate the audio with ElevenLabs
        // Use the imported function from the top of the file
        const audioStream = await getTtsStream(text, ttsOptions);
        
        // Generate file path
        const timestamp = Date.now();
        const filename = `voice_${timestamp}.mp3`;
        const tempDir = path.resolve(process.cwd(), 'temp');
        
        // Create temp directory if it doesn't exist
        if (!fs.existsSync(tempDir)) {
          fs.mkdirSync(tempDir, { recursive: true });
        }
        
        const audioPath = path.join(tempDir, filename);
        
        // Save the audio stream to a file
        const fileStream = fs.createWriteStream(audioPath);
        audioStream.pipe(fileStream);
        
        await new Promise((resolve, reject) => {
          fileStream.on('finish', resolve);
          fileStream.on('error', reject);
        });
        
        // Return success response with updated coin balance and audio URL
        const updatedCoins = await storage.getUserCoins(user.id);
        
        res.json({ 
          success: true, 
          coins: updatedCoins,
          wordCount,
          coinCost,
          audioUrl: `/temp/${filename}`,
          message: `Successfully generated voiceover using ${coinCost} coins`,
          transaction_id: coinTransaction.id
        });
      } catch (err) {
        // If anything fails after deducting coins, refund the coins
        await storage.addUserCoins(
          user.id,
          coinCost,
          TransactionType.REFUND,
          `Refund for failed voiceover generation (${wordCount} words)`
        );
        
        throw err; // Rethrow to be caught by the outer try-catch
      }
    } catch (error) {
      console.error("Error processing voiceover request:", error);
      await logMessage(LogLevel.ERROR, 'Coins', `Error processing voiceover request: ${error instanceof Error ? error.message : String(error)}`);
      res.status(500).json({ error: "Failed to process voiceover request", details: error instanceof Error ? error.message : String(error) });
    }
  });
  
  // Image generation API routes
  // Text to Image - Generate an image from a text prompt
  app.post('/api/image/generate', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      const { prompt, size } = req.body;
      
      if (!prompt || typeof prompt !== 'string') {
        return res.status(400).json({ error: 'Invalid request. Required field: prompt' });
      }
      
      // Check if prompt is too short
      if (prompt.trim().length < 3) {
        return res.status(400).json({ error: 'Prompt is too short. Please provide a more detailed description.' });
      }
      
      // The cost for image generation is 5 coins per image
      const coinCost = 5;
      
      // Check if user has enough coins
      const userCoins = await storage.getUserCoins(user.id);
      
      if (userCoins < coinCost) {
        return res.status(403).json({ 
          error: 'Insufficient coins', 
          required: coinCost, 
          available: userCoins,
          message: `You need ${coinCost} coins to generate this image, but you only have ${userCoins} coins.`
        });
      }
      
      try {
        // First deduct coins from the user account
        const deductResult = await storage.deductUserCoins(
          user.id,
          coinCost,
          `Generated AI image from text`
        );
        
        if (!deductResult) {
          return res.status(403).json({ error: 'Failed to deduct coins from account' });
        }
        
        // Log the coin deduction
        await logMessage(LogLevel.INFO, 'Coins', `User ${user.email} used ${coinCost} coins for image generation`);
        
        // Get the coin transaction for this deduction (most recent transaction for this user)
        const transactions = await storage.getCoinTransactions(user.id, 1);
        const coinTransaction = transactions[0];
        
        if (!coinTransaction) {
          throw new Error('Coin transaction not found - this should never happen');
        }
        
        // Use OpenAI's DALL-E 3 model with the new API key
        const result = await generateImageFromText(
          prompt,
          user.id,
          size || "1024x1024",
          "dall-e-3"
        );
        
        // Return success response with updated coin balance and image URL
        const updatedCoins = await storage.getUserCoins(user.id);
        
        res.json({ 
          success: true, 
          coins: updatedCoins,
          coinCost,
          imageUrl: result.url,
          promptUsed: result.promptUsed,
          message: `Successfully generated image using ${coinCost} coins`,
          transaction_id: coinTransaction.id
        });
      } catch (err) {
        // If anything fails after deducting coins, refund the coins
        await storage.addUserCoins(
          user.id,
          coinCost,
          TransactionType.REFUND,
          `Refund for failed image generation`
        );
        
        throw err; // Rethrow to be caught by the outer try-catch
      }
    } catch (error) {
      console.error("Error processing image generation request:", error);
      await logMessage(LogLevel.ERROR, 'Coins', `Error processing image generation request: ${error instanceof Error ? error.message : String(error)}`);
      res.status(500).json({ error: "Failed to process image generation request", details: error instanceof Error ? error.message : String(error) });
    }
  });
  
  // Image + Text to Image - Create an image variation from an existing image
  app.post('/api/image/edit', isAuthenticated, uploadSingleImage, async (req, res) => {
    try {
      const user = (req as any).user;
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      const { prompt, size } = req.body;
      
      if (!prompt || typeof prompt !== 'string') {
        return res.status(400).json({ error: 'Invalid request. Required field: prompt' });
      }
      
      // Check if an image was uploaded
      if (!req.file) {
        return res.status(400).json({ error: 'No image file uploaded. Please upload an image file.' });
      }
      
      // The cost for image editing is 5 coins per edit
      const coinCost = 5;
      
      // Check if user has enough coins
      const userCoins = await storage.getUserCoins(user.id);
      
      if (userCoins < coinCost) {
        // Clean up the uploaded file if the user doesn't have enough coins
        if (req.file) {
          fs.unlinkSync(req.file.path);
        }
        
        return res.status(403).json({ 
          error: 'Insufficient coins', 
          required: coinCost, 
          available: userCoins,
          message: `You need ${coinCost} coins to edit this image, but you only have ${userCoins} coins.`
        });
      }
      
      try {
        // First deduct coins from the user account
        const deductResult = await storage.deductUserCoins(
          user.id,
          coinCost,
          `Generated AI image from image+text`
        );
        
        if (!deductResult) {
          // Clean up the uploaded file
          if (req.file) {
            fs.unlinkSync(req.file.path);
          }
          
          return res.status(403).json({ error: 'Failed to deduct coins from account' });
        }
        
        // Log the coin deduction
        await logMessage(LogLevel.INFO, 'Coins', `User ${user.email} used ${coinCost} coins for image editing`);
        
        // Get the coin transaction for this deduction (most recent transaction for this user)
        const transactions = await storage.getCoinTransactions(user.id, 1);
        const coinTransaction = transactions[0];
        
        if (!coinTransaction) {
          throw new Error('Coin transaction not found - this should never happen');
        }
        
        // Use OpenAI's DALL-E 3 model with the new API key
        const result = await generateImageFromImageAndText(
          prompt,
          req.file.path,
          user.id,
          size || "1024x1024",
          "dall-e-3"
        );
        
        // Clean up the temporary uploaded file since we don't need it anymore
        fs.unlinkSync(req.file.path);
        
        // Return success response with updated coin balance and image URL
        const updatedCoins = await storage.getUserCoins(user.id);
        
        res.json({ 
          success: true, 
          coins: updatedCoins,
          coinCost,
          imageUrl: result.url,
          promptUsed: result.promptUsed,
          message: `Successfully edited image using ${coinCost} coins`,
          transaction_id: coinTransaction.id
        });
      } catch (err) {
        // Clean up the uploaded file if there was an error
        if (req.file) {
          fs.unlinkSync(req.file.path);
        }
        
        // If anything fails after deducting coins, refund the coins
        await storage.addUserCoins(
          user.id,
          coinCost,
          TransactionType.REFUND,
          `Refund for failed image editing`
        );
        
        throw err; // Rethrow to be caught by the outer try-catch
      }
    } catch (error) {
      console.error("Error processing image editing request:", error);
      await logMessage(LogLevel.ERROR, 'Coins', `Error processing image editing request: ${error instanceof Error ? error.message : String(error)}`);
      res.status(500).json({ error: "Failed to process image editing request", details: error instanceof Error ? error.message : String(error) });
    }
  });
  
  // Payment verification endpoint is now implemented below at line ~1260
  
  // Get all user agents
  app.get('/api/user/agents', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      const agents = await storage.getUserAgents(user.id);
      res.json(agents);
    } catch (error) {
      console.error("Error getting user agents:", error);
      res.status(500).json({ error: "Failed to get user agents" });
    }
  });
  
  // Create a user agent
  app.post('/api/user/agents', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      // Add userId to the agent data
      const agentData = {
        ...req.body,
        user_id: user.id
      };
      
      const newAgent = await storage.createUserAgentWithPhone(agentData);
      
      await logMessage(LogLevel.INFO, 'Agent', `Created new user agent "${newAgent.name}" for user ${user.email}`);
      res.status(201).json(newAgent);
    } catch (error) {
      console.error("Error creating user agent:", error);
      res.status(500).json({ error: "Failed to create user agent", details: error instanceof Error ? error.message : String(error) });
    }
  });
  
  // Update a specific user agent
  app.patch('/api/user/agents/:id', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      const agentId = parseInt(req.params.id);
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      // Get the agent to make sure it belongs to the user
      const agent = await storage.getUserAgentById(agentId);
      
      if (!agent) {
        return res.status(404).json({ error: 'Agent not found' });
      }
      
      // Verify that the agent belongs to the user
      if (agent.user_id !== user.id) {
        return res.status(403).json({ error: 'Not authorized to update this agent' });
      }
      
      // Update the agent
      const updatedAgent = await storage.updateUserAgentById(agentId, req.body);
      
      if (!updatedAgent) {
        return res.status(404).json({ error: 'Failed to update agent' });
      }
      
      await logMessage(LogLevel.INFO, 'Agent', `Updated user agent "${updatedAgent.name}" for user ${user.email}`);
      res.json(updatedAgent);
    } catch (error) {
      console.error("Error updating user agent:", error);
      res.status(500).json({ error: "Failed to update user agent", details: error instanceof Error ? error.message : String(error) });
    }
  });
  
  // Delete a specific user agent
  app.delete('/api/user/agents/:id', isAuthenticated, async (req, res) => {
    try {
      console.log(`DELETE request received for agent ID: ${req.params.id}`);
      const user = (req as any).user;
      const agentId = parseInt(req.params.id);
      
      if (!user) {
        console.error('Delete agent failed: User not authenticated');
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      console.log(`User authenticated: ${user.email}, user ID: ${user.id}`);
      
      // Get the agent to make sure it belongs to the user
      const agent = await storage.getUserAgentById(agentId);
      
      if (!agent) {
        console.error(`Delete agent failed: Agent with ID ${agentId} not found`);
        return res.status(404).json({ error: 'Agent not found' });
      }
      
      console.log(`Agent found: ${agent.name}, belongs to user ID: ${agent.user_id}`);
      
      // Verify that the agent belongs to the user
      if (agent.user_id !== user.id) {
        console.error(`Delete agent failed: Agent (${agentId}) belongs to user ${agent.user_id}, not ${user.id}`);
        return res.status(403).json({ error: 'Not authorized to delete this agent' });
      }
      
      console.log(`Authorization confirmed for deleting agent ${agentId}`);
      
      // Delete the agent
      console.log(`Attempting to delete agent ${agentId} from database...`);
      const deleted = await storage.deleteUserAgentById(agentId);
      
      if (!deleted) {
        console.error(`Database operation failed to delete agent ${agentId}`);
        return res.status(400).json({ error: 'Failed to delete agent' });
      }
      
      console.log(`Successfully deleted agent ${agentId} from database`);
      await logMessage(LogLevel.INFO, 'Agent', `Deleted user agent "${agent.name}" for user ${user.email}`);
      
      console.log(`Sending 204 success response for agent ${agentId} deletion`);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting user agent:", error);
      await logMessage(LogLevel.ERROR, 'Agent', `Error deleting agent: ${error instanceof Error ? error.message : String(error)}`);
      res.status(500).json({ error: "Failed to delete user agent", details: error instanceof Error ? error.message : String(error) });
    }
  });
  
  // Delete all agents for a user
  app.delete('/api/user/agents', isAuthenticated, async (req, res) => {
    try {
      console.log(`DELETE ALL request received for user agents`);
      const user = (req as any).user;
      
      if (!user) {
        console.error('Delete all agents failed: User not authenticated');
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      console.log(`User authenticated: ${user.email}, user ID: ${user.id}`);
      
      // Get all user agents
      const userAgents = await storage.getUserAgents(user.id);
      
      if (userAgents.length === 0) {
        console.log(`No agents found for user ${user.id}`);
        return res.status(200).json({ message: 'No agents to delete', deletedCount: 0 });
      }
      
      console.log(`Found ${userAgents.length} agents to delete for user ${user.id}`);
      
      // Delete all agents
      const results = await Promise.all(
        userAgents.map(async (agent) => {
          try {
            return await storage.deleteUserAgentById(agent.id);
          } catch (error) {
            console.error(`Error deleting agent ${agent.id}:`, error);
            return false;
          }
        })
      );
      
      const successCount = results.filter(Boolean).length;
      
      console.log(`Successfully deleted ${successCount} out of ${userAgents.length} agents for user ${user.id}`);
      await logMessage(LogLevel.INFO, 'Agent', `Deleted ${successCount} agents for user ${user.email}`);
      
      res.status(200).json({ 
        message: `Successfully deleted ${successCount} agents`,
        deletedCount: successCount,
        totalCount: userAgents.length
      });
    } catch (error) {
      console.error("Error deleting all user agents:", error);
      await logMessage(LogLevel.ERROR, 'Agent', `Error deleting all agents: ${error instanceof Error ? error.message : String(error)}`);
      res.status(500).json({ error: "Failed to delete all agents", details: error instanceof Error ? error.message : String(error) });
    }
  });
  
  // Get a specific user agent by ID
  app.get('/api/user/agents/:id', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      const agentId = parseInt(req.params.id);
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      if (isNaN(agentId)) {
        return res.status(400).json({ error: 'Invalid agent ID' });
      }
      
      const agent = await storage.getUserAgentById(agentId);
      
      if (!agent) {
        return res.status(404).json({ error: 'Agent not found' });
      }
      
      // Verify that the agent belongs to the user
      if (agent.user_id !== user.id && !user.isAdmin) {
        return res.status(403).json({ error: 'Not authorized to view this agent' });
      }
      
      await logMessage(LogLevel.INFO, 'Agent', `Retrieved agent details for "${agent.name}" by user ${user.email}`);
      res.json(agent);
    } catch (error) {
      console.error("Error retrieving user agent:", error);
      res.status(500).json({ error: "Failed to retrieve user agent", details: error instanceof Error ? error.message : String(error) });
    }
  });
  
  // API route to check if PayPal integration is working
  app.get('/api/system/check-paypal', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const result = await testPayPalCredentials();
      await logMessage(
        result.isValid ? LogLevel.INFO : LogLevel.ERROR, 
        'System', 
        `PayPal credentials check: ${result.message}`
      );
      
      // Log additional details for debugging
      if (!result.isValid) {
        console.log('PayPal check details:', JSON.stringify(result.details, null, 2));
      }
      
      return res.json({
        isValid: result.isValid,
        message: result.message,
        details: result.details || {}
      });
    } catch (error: any) {
      console.error('Error checking PayPal credentials:', error);
      await logMessage(LogLevel.ERROR, 'System', `Error checking PayPal credentials: ${error.message}`);
      return res.status(500).json({ 
        isValid: false, 
        message: `Error: ${error.message}`,
        details: {
          error: error.message,
          stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
        }
      });
    }
  });
  
  // Add a debug route to check environment variables
  app.get('/api/debug/env', (req, res) => {
    res.json({
      environment: {
        NODE_ENV: process.env.NODE_ENV || 'not set',
        REPL_SLUG: process.env.REPL_SLUG || 'not set',
        REPL_OWNER: process.env.REPL_OWNER || 'not set'
      },
      auth: {
        type: 'token-based',
        hasAuthHeader: !!req.headers.authorization,
        cookieCount: Object.keys(req.cookies || {}).length
      }
    });
  });
  
  // Enhanced debugging endpoints for troubleshooting
  app.get('/api/debug/headers', (req, res) => {
    const isProduction = process.env.REPL_SLUG === 'node-ninja-emilghelmeci';
    console.log(`Debug headers called from environment: ${isProduction ? 'Production' : 'Development'}`);
    
    res.json({
      headers: req.headers,
      ip: req.ip,
      originalUrl: req.originalUrl,
      hostname: req.hostname,
      protocol: req.protocol,
      cookies: req.cookies,
      env: {
        REPL_SLUG: process.env.REPL_SLUG,
        NODE_ENV: process.env.NODE_ENV,
        isProduction
      }
    });
  });
  
  // Add a route to check token store status
  app.get('/api/debug/auth', isAuthenticated, (req, res) => {
    res.json({
      message: 'Authentication is working properly',
      user: (req as any).user
    });
  });
  
  // Add a diagnostic endpoint to verify token validity without requiring auth
  app.post('/api/debug/verify-token', async (req, res) => {
    try {
      let token = '';
      
      // Get token from the request
      if (req.headers.authorization && req.headers.authorization.startsWith('Bearer ')) {
        token = req.headers.authorization.substring(7);
      } else if (req.body && req.body.token) {
        token = req.body.token;
      } else if (req.cookies && req.cookies.auth_token) {
        token = req.cookies.auth_token;
      }
      
      if (!token) {
        return res.status(400).json({
          valid: false,
          message: 'No token provided',
          authHeader: !!req.headers.authorization,
          hasCookies: Object.keys(req.cookies || {}).length > 0,
          cookieNames: Object.keys(req.cookies || {})
        });
      }
      
      console.log(`Verifying token: ${token.substring(0, 10)}...`);
      
      // Check if token exists in memory
      const tokenInfo = activeTokens.get(token);
      
      if (!tokenInfo) {
        console.log('Token not found in memory store');
        
        // Check if token exists in database
        const dbResult = await pool.query(
          'SELECT user_id, expires_at FROM auth_tokens WHERE token = $1',
          [token]
        );
        
        if (dbResult.rows.length === 0) {
          return res.json({
            valid: false,
            message: 'Token not found in memory or database',
            inMemory: false,
            inDatabase: false,
            memoryTokenCount: activeTokens.size
          });
        }
        
        // Token in database but not in memory (this shouldn't happen normally)
        return res.json({
          valid: false,
          message: 'Token found in database but not in memory store',
          inMemory: false, 
          inDatabase: true,
          userId: dbResult.rows[0].user_id,
          expiresAt: dbResult.rows[0].expires_at,
          expired: new Date(dbResult.rows[0].expires_at) < new Date(),
          memoryTokenCount: activeTokens.size
        });
      }
      
      // Token found in memory, check if expired
      if (tokenInfo.expiresAt < new Date()) {
        return res.json({
          valid: false,
          message: 'Token is expired',
          inMemory: true,
          expired: true,
          userId: tokenInfo.userId,
          expiresAt: tokenInfo.expiresAt
        });
      }
      
      // Token is valid, get the user
      const user = await storage.getUser(tokenInfo.userId);
      
      if (!user) {
        return res.json({
          valid: false,
          message: 'Token valid but user not found',
          inMemory: true,
          expired: false,
          userId: tokenInfo.userId,
          expiresAt: tokenInfo.expiresAt
        });
      }
      
      // Success case
      return res.json({
        valid: true,
        message: 'Token is valid',
        inMemory: true,
        expired: false,
        userId: tokenInfo.userId,
        userEmail: user.email,
        expiresIn: Math.round((tokenInfo.expiresAt.getTime() - new Date().getTime()) / 1000 / 60) + ' minutes'
      });
      
    } catch (error) {
      console.error('Error checking token:', error);
      return res.status(500).json({
        valid: false,
        message: 'Server error checking token',
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });
  
  // Add a route to test database connection
  app.get('/api/debug/database', async (req, res) => {
    try {
      console.log('[DEBUG] Testing database connection');
      const result = await pool.query('SELECT NOW() as time, current_database() as database');
      
      // Try to query a user to test if schema exists
      let userCount = 0;
      let testUser = null;
      
      try {
        const userResult = await pool.query('SELECT COUNT(*) as count FROM users');
        userCount = parseInt(userResult.rows[0].count);
        
        if (userCount > 0) {
          // Get first user (without password)
          const testUserResult = await pool.query('SELECT id, username, email, "displayName", "isAdmin" FROM users LIMIT 1');
          testUser = testUserResult.rows[0];
        }
      } catch (schemaError: any) {
        console.error('[DEBUG] Schema test error:', schemaError.message);
      }
      
      res.json({
        dbConnected: true,
        timeCheck: result.rows[0],
        schemaExists: userCount !== null,
        userCount,
        testUser,
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      console.error('[DEBUG] Database test error:', error);
      
      res.status(500).json({
        dbConnected: false,
        error: error.message,
        stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
        timestamp: new Date().toISOString()
      });
    }
  });

  // Authentication routes
  app.post('/api/auth/register', async (req, res) => {
    try {
      const { username, email, password, displayName } = req.body;
      
      if (!username || !email || !password) {
        return res.status(400).json({ error: 'Username, email, and password are required' });
      }
      
      // Register the user
      const user = await registerUser(username, email, password, displayName);
      
      // Login the user with our token-based system
      const result = await loginUser(email, password);
      
      await logMessage(LogLevel.INFO, 'Auth', `User registered: ${email}`);
      
      // The result already contains all the user data, token and expiry
      return res.status(201).json(result);
      
    } catch (error) {
      if (error instanceof Error) {
        console.error(`[${LogLevel.ERROR}] [Auth] Registration error:`, error);
        await logMessage(LogLevel.ERROR, 'Auth', `Registration error: ${error.message}`);
        return res.status(400).json({ error: error.message });
      }
      
      // Handle non-Error objects
      console.error(`[${LogLevel.ERROR}] [Auth] Registration error:`, error);
      await logMessage(LogLevel.ERROR, 'Auth', `Registration error: Unknown error occurred`);
      return res.status(400).json({ error: 'Unknown error occurred' });
    }
  });
  
  // Admin Panel Routes
  // User management endpoints
  app.get('/api/admin/users', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const users = await pool.query('SELECT id, username, email, display_name as "displayName", created_at as "createdAt", last_login as "lastLogin", is_admin as "isAdmin" FROM users ORDER BY id');
      res.json(users.rows);
    } catch (error) {
      console.error('Error fetching users:', error);
      await logMessage(LogLevel.ERROR, 'Admin', `Error fetching users: ${error}`);
      res.status(500).json({ error: 'Failed to fetch users' });
    }
  });
  
  app.get('/api/admin/users/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const userResult = await pool.query(
        'SELECT id, username, email, display_name as "displayName", created_at as "createdAt", last_login as "lastLogin", is_admin as "isAdmin" FROM users WHERE id = $1',
        [id]
      );
      
      if (userResult.rows.length === 0) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      // Get user agent
      let agent = null;
      try {
        agent = await storage.getUserAgent(parseInt(id));
      } catch (agentError) {
        console.error('Error fetching user agent:', agentError);
      }
      
      // Get API usage
      const apiUsageResult = await pool.query(
        `SELECT service, SUM(request_count) as total_requests, 
         AVG(response_time) as avg_response_time,
         SUM(character_count) as total_characters,
         SUM(token_count) as total_tokens
         FROM api_metrics 
         WHERE agent_id IN (SELECT id FROM agents WHERE user_id = $1)
         GROUP BY service`,
        [id]
      );
      
      res.json({
        ...userResult.rows[0],
        agent,
        apiUsage: apiUsageResult.rows
      });
    } catch (error) {
      console.error(`Error fetching user ${req.params.id}:`, error);
      await logMessage(LogLevel.ERROR, 'Admin', `Error fetching user ${req.params.id}: ${error}`);
      res.status(500).json({ error: 'Failed to fetch user' });
    }
  });
  
  app.patch('/api/admin/users/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { username, email, displayName, isAdmin: userIsAdmin } = req.body;
      
      // Prevent non-admins from creating admin users
      // Additional security check even though route is protected by isAdmin middleware
      if (userIsAdmin && !(req.user as any).isAdmin) {
        return res.status(403).json({ error: 'Not authorized to create admin users' });
      }
      
      const updateResult = await pool.query(
        `UPDATE users 
         SET username = COALESCE($1, username),
             email = COALESCE($2, email),
             display_name = COALESCE($3, display_name),
             is_admin = COALESCE($4, is_admin)
         WHERE id = $5
         RETURNING id, username, email, display_name as "displayName", is_admin as "isAdmin"`,
        [username, email, displayName, userIsAdmin, id]
      );
      
      if (updateResult.rows.length === 0) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      await logMessage(LogLevel.INFO, 'Admin', `User ${id} updated by admin ${(req.user as any).id}`);
      res.json(updateResult.rows[0]);
    } catch (error) {
      console.error(`Error updating user ${req.params.id}:`, error);
      await logMessage(LogLevel.ERROR, 'Admin', `Error updating user ${req.params.id}: ${error}`);
      res.status(500).json({ error: 'Failed to update user' });
    }
  });
  
  app.delete('/api/admin/users/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      // Prevent deleting admin users
      const userResult = await pool.query('SELECT is_admin FROM users WHERE id = $1', [id]);
      if (userResult.rows.length === 0) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      if (userResult.rows[0].is_admin) {
        return res.status(403).json({ error: 'Cannot delete admin users' });
      }
      
      // Delete user agents first
      await pool.query('DELETE FROM agents WHERE user_id = $1', [id]);
      
      // Delete user
      await pool.query('DELETE FROM users WHERE id = $1', [id]);
      
      await logMessage(LogLevel.INFO, 'Admin', `User ${id} deleted by admin ${(req.user as any).id}`);
      res.json({ success: true });
    } catch (error) {
      console.error(`Error deleting user ${req.params.id}:`, error);
      await logMessage(LogLevel.ERROR, 'Admin', `Error deleting user ${req.params.id}: ${error}`);
      res.status(500).json({ error: 'Failed to delete user' });
    }
  });
  
  // Reset user password
  app.post('/api/admin/users/:id/reset-password', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { newPassword } = req.body;
      
      if (!newPassword || newPassword.length < 8) {
        return res.status(400).json({ error: 'New password must be at least 8 characters' });
      }
      
      // Hash the new password
      const bcrypt = require('bcrypt');
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      const updateResult = await pool.query(
        'UPDATE users SET password = $1 WHERE id = $2 RETURNING id, username, email',
        [hashedPassword, id]
      );
      
      if (updateResult.rows.length === 0) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      await logMessage(LogLevel.INFO, 'Admin', `Password reset for user ${id} by admin ${(req.user as any).id}`);
      res.json({ success: true, user: updateResult.rows[0] });
    } catch (error) {
      console.error(`Error resetting password for user ${req.params.id}:`, error);
      await logMessage(LogLevel.ERROR, 'Admin', `Error resetting password for user ${req.params.id}: ${error}`);
      res.status(500).json({ error: 'Failed to reset password' });
    }
  });
  
  // System stats for admin dashboard
  app.get('/api/admin/stats', isAuthenticated, isAdmin, async (req, res) => {
    try {
      // Get user count
      const userCountResult = await pool.query('SELECT COUNT(*) as count FROM users');
      const userCount = parseInt(userCountResult.rows[0].count);
      
      // Get active agent count
      const agentCountResult = await pool.query('SELECT COUNT(*) as count FROM agents WHERE active = true');
      const activeAgentCount = parseInt(agentCountResult.rows[0].count);
      
      // Get API usage statistics
      const apiStatsResult = await pool.query(`
        SELECT 
          service, 
          SUM(request_count) as total_requests, 
          AVG(response_time) as avg_response_time
        FROM api_metrics
        GROUP BY service
      `);
      
      // Get recent logs (last 20)
      const logsResult = await pool.query(`
        SELECT * FROM logs
        ORDER BY timestamp DESC
        LIMIT 20
      `);
      
      // Get system uptime and resources
      const uptime = calculateUptime();
      const cpuUsage = process.cpuUsage();
      const cpuPercent = Math.round((cpuUsage.user + cpuUsage.system) / 1000000 / os.cpus().length * 10);
      
      const totalMem = Math.round(os.totalmem() / (1024 * 1024)); // MB
      const freeMem = Math.round(os.freemem() / (1024 * 1024)); // MB
      const usedMem = totalMem - freeMem;
      
      res.json({
        users: {
          total: userCount,
          activeAgents: activeAgentCount
        },
        apiStats: apiStatsResult.rows,
        recentLogs: logsResult.rows,
        system: {
          uptime,
          cpu: cpuPercent > 100 ? 100 : cpuPercent,
          memory: {
            used: usedMem,
            total: totalMem,
            percent: Math.round((usedMem / totalMem) * 100)
          }
        }
      });
    } catch (error) {
      console.error('Error fetching admin stats:', error);
      await logMessage(LogLevel.ERROR, 'Admin', `Error fetching admin stats: ${error}`);
      res.status(500).json({ error: 'Failed to fetch admin stats' });
    }
  });
  
  // Get all logs with pagination and filtering
  app.get('/api/admin/logs', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 50;
      const offset = (page - 1) * limit;
      const level = req.query.level as string;
      const source = req.query.source as string;
      
      let query = 'SELECT * FROM logs';
      const queryParams: any[] = [];
      let whereClause = '';
      
      if (level) {
        whereClause += 'level = $1';
        queryParams.push(level);
      }
      
      if (source) {
        if (whereClause) {
          whereClause += ' AND ';
          queryParams.push(source);
          whereClause += `source = $${queryParams.length}`;
        } else {
          whereClause += 'source = $1';
          queryParams.push(source);
        }
      }
      
      if (whereClause) {
        query += ` WHERE ${whereClause}`;
      }
      
      query += ' ORDER BY timestamp DESC';
      
      // Add pagination
      queryParams.push(limit);
      queryParams.push(offset);
      query += ` LIMIT $${queryParams.length - 1} OFFSET $${queryParams.length}`;
      
      const logsResult = await pool.query(query, queryParams);
      
      // Get total count for pagination
      let countQuery = 'SELECT COUNT(*) as count FROM logs';
      if (whereClause) {
        countQuery += ` WHERE ${whereClause}`;
      }
      
      const countParams = queryParams.slice(0, -2); // Remove limit and offset
      const countResult = await pool.query(countQuery, countParams);
      const totalCount = parseInt(countResult.rows[0].count);
      
      res.json({
        logs: logsResult.rows,
        pagination: {
          page,
          limit,
          totalCount,
          totalPages: Math.ceil(totalCount / limit)
        }
      });
    } catch (error) {
      console.error('Error fetching logs:', error);
      await logMessage(LogLevel.ERROR, 'Admin', `Error fetching logs: ${error}`);
      res.status(500).json({ error: 'Failed to fetch logs' });
    }
  });
  
  // API Configuration endpoints
  app.get('/api/admin/config', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const config = await storage.getConfig();
      res.json(config);
    } catch (error) {
      console.error('Error fetching configuration:', error);
      await logMessage(LogLevel.ERROR, 'Admin', `Error fetching configuration: ${error}`);
      res.status(500).json({ error: 'Failed to fetch configuration' });
    }
  });
  
  app.patch('/api/admin/config', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const updatedConfig = await storage.updateConfig(req.body);
      await logMessage(LogLevel.INFO, 'Admin', `System configuration updated by admin ${(req.user as any).id}`);
      res.json(updatedConfig);
    } catch (error) {
      console.error('Error updating configuration:', error);
      await logMessage(LogLevel.ERROR, 'Admin', `Error updating configuration: ${error}`);
      res.status(500).json({ error: 'Failed to update configuration' });
    }
  });
  
  // Agent template management (only for admins)
  app.get('/api/admin/templates', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const templates = await storage.getAgentTemplates();
      res.json(templates);
    } catch (error) {
      console.error('Error fetching agent templates:', error);
      await logMessage(LogLevel.ERROR, 'Admin', `Error fetching agent templates: ${error}`);
      res.status(500).json({ error: 'Failed to fetch agent templates' });
    }
  });
  
  app.post('/api/admin/templates', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const newTemplate = await storage.createAgentTemplate(req.body);
      await logMessage(LogLevel.INFO, 'Admin', `New agent template created by admin ${(req.user as any).id}`);
      res.status(201).json(newTemplate);
    } catch (error) {
      console.error('Error creating agent template:', error);
      await logMessage(LogLevel.ERROR, 'Admin', `Error creating agent template: ${error}`);
      res.status(500).json({ error: 'Failed to create agent template' });
    }
  });
  
  app.patch('/api/admin/templates/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const updatedTemplate = await storage.updateAgentTemplate(parseInt(id), req.body);
      
      if (!updatedTemplate) {
        return res.status(404).json({ error: 'Template not found' });
      }
      
      await logMessage(LogLevel.INFO, 'Admin', `Agent template ${id} updated by admin ${(req.user as any).id}`);
      res.json(updatedTemplate);
    } catch (error) {
      console.error(`Error updating agent template ${req.params.id}:`, error);
      await logMessage(LogLevel.ERROR, 'Admin', `Error updating agent template ${req.params.id}: ${error}`);
      res.status(500).json({ error: 'Failed to update agent template' });
    }
  });
  
  app.delete('/api/admin/templates/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const success = await storage.deleteAgentTemplate(parseInt(id));
      
      if (!success) {
        return res.status(404).json({ error: 'Template not found' });
      }
      
      await logMessage(LogLevel.INFO, 'Admin', `Agent template ${id} deleted by admin ${(req.user as any).id}`);
      res.json({ success: true });
    } catch (error) {
      console.error(`Error deleting agent template ${req.params.id}:`, error);
      await logMessage(LogLevel.ERROR, 'Admin', `Error deleting agent template ${req.params.id}: ${error}`);
      res.status(500).json({ error: 'Failed to delete agent template' });
    }
  });
  
  app.post('/api/auth/login', async (req, res) => {
    try {
      console.log('Login attempt:', req.body.email);
      
      const { email, password } = req.body;
      
      if (!email || !password) {
        return res.status(400).json({ error: 'Email and password are required' });
      }
      
      // Use our token-based authentication
      const result = await loginUser(email, password);
      
      // Log success
      console.log('Login successful for user:', result.email);
      logMessage(LogLevel.INFO, 'Auth', `User logged in: ${result.email}`);
      
      // Set the token in a cookie for better cross-environment compatibility
      const cookieOptions = {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
        sameSite: 'lax' as const,
        path: '/'
      };
      
      // Set the token cookie
      res.cookie('auth_token', result.token, cookieOptions);
      
      // Log cookie setting for debugging
      console.log('Setting auth_token cookie with options:', cookieOptions);
      
      // Return complete result including the token in the response body
      return res.json(result);
      
    } catch (error) {
      console.error('Login error:', error);
      const errorMessage = error instanceof Error ? error.message : 'Authentication failed';
      return res.status(401).json({ error: errorMessage });
    }
  });
  
  app.post('/api/auth/logout', async (req, res) => {
    // Get the token from any available source (header or cookie)
    const authHeader = req.headers.authorization;
    let token: string | undefined;
    
    // Try to get token from Authorization header
    if (authHeader && authHeader.startsWith('Bearer ')) {
      token = authHeader.substring(7); // Remove 'Bearer ' prefix
    }
    
    // If no token in header, try cookie as a fallback
    if (!token && req.cookies?.auth_token) {
      token = req.cookies.auth_token;
    }
    
    if (!token) {
      return res.status(400).json({ error: 'Token is required' });
    }
    
    try {
      // Use our token-based logout (now async)
      const result = await logoutUser(token);
      
      // Always clear the cookie regardless of token validity
      res.clearCookie('auth_token', {
        path: '/',
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax'
      });
      
      await logMessage(LogLevel.INFO, 'Auth', `User logout ${result ? 'successful' : 'failed but cookie cleared'}`);
      
      if (result) {
        return res.status(200).json({ message: 'Logged out successfully' });
      } else {
        return res.status(400).json({ error: 'Invalid token, but cookie cleared' });
      }
    } catch (error) {
      console.error('Logout error:', error);
      // Still clear the cookie
      res.clearCookie('auth_token', {
        path: '/',
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax'
      });
      
      return res.status(500).json({ error: 'Error during logout, but cookie cleared' });
    }
  });
  
  app.get('/api/auth/me', isAuthenticated, (req, res) => {
    console.log('Auth check for user:', (req.user as any).email);
    
    // Return sanitized user object (without password and with explicit typecasting)
    const { password, ...userWithoutPassword } = req.user as any;
    
    // Log cookies for debugging
    console.log('Auth check cookies:', req.cookies);
    
    res.json(userWithoutPassword);
  });
  
  // Add a duplicate endpoint for backward compatibility
  app.get('/api/auth/user', isAuthenticated, (req, res) => {
    console.log('Auth check (via /user endpoint) for user:', (req.user as any).email);
    
    // Return sanitized user object (without password and with explicit typecasting)
    const { password, ...userWithoutPassword } = req.user as any;
    
    res.json(userWithoutPassword);
  });
  
  // Add an endpoint to register tokens from client
  app.post('/api/auth/register-token', async (req, res) => {
    try {
      const { token, userId } = req.body;
      
      if (!token || !userId) {
        return res.status(400).json({ error: 'Token and userId are required' });
      }
      
      const success = await registerToken(token, userId);
      
      if (success) {
        return res.status(200).json({ message: 'Token registered successfully' });
      } else {
        return res.status(400).json({ error: 'Failed to register token' });
      }
    } catch (error) {
      console.error('Error registering token:', error);
      return res.status(500).json({ error: 'Server error' });
    }
  });
  
  // User Agent endpoints
  app.get('/api/user/agent', isAuthenticated, async (req, res) => {
    try {
      // The isAuthenticated middleware has already verified the user is authenticated
      // and set the user object on the request
      const user = (req as any).user;
      console.log('User from request:', user ? `ID: ${user.id}, Email: ${user.email}` : 'No user found');
      
      if (!user) {
        return res.status(401).json({ error: 'User not authenticated' });
      }
      
      // Get or create a user's agent if it doesn't exist
      let agent = await storage.getUserAgent(user.id);
      console.log('Agent found?', !!agent);
      
      if (!agent) {
        // Create a default agent for the user if one doesn't exist
        console.log('Creating new agent for user', user.id);
        agent = await storage.createUserAgent(user.id);
        logMessage(LogLevel.INFO, 'Agent', `Created new agent for user ${user.email}`);
      }
      
      res.json(agent);
    } catch (error: any) {
      console.error('Error getting user agent:', error);
      res.status(500).json({ error: 'Failed to retrieve agent', details: error?.message || 'Unknown error' });
    }
  });
  
  // Update the current user's agent
  app.patch('/api/user/agent', isAuthenticated, async (req, res) => {
    try {
      const user = (req as any).user;
      const agent = await storage.getUserAgent(user.id);
      
      if (!agent) {
        return res.status(404).json({ error: 'Agent not found' });
      }
      
      // Update agent with the provided fields
      const updatedAgent = await storage.updateAgent(agent.id, req.body);
      
      if (!updatedAgent) {
        return res.status(404).json({ error: 'Failed to update agent' });
      }
      
      logMessage(LogLevel.INFO, 'Agent', `Updated agent for user ${user.email}`);
      res.json(updatedAgent);
    } catch (error) {
      console.error('Error updating user agent:', error);
      res.status(500).json({ error: 'Failed to update agent' });
    }
  });
  
  // Get agent templates
  app.get('/api/agent-templates', isAuthenticated, async (req, res) => {
    try {
      const templates = await storage.getAgentTemplates();
      res.json(templates);
    } catch (error) {
      console.error('Error fetching agent templates:', error);
      res.status(500).json({ error: 'Failed to retrieve agent templates' });
    }
  });
  
  // Admin-only endpoint to create a new agent template
  app.post('/api/agent-templates', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const template = await storage.createAgentTemplate(req.body);
      logMessage(LogLevel.INFO, 'Agent', `Admin created new agent template: ${template.name}`);
      res.status(201).json(template);
    } catch (error) {
      console.error('Error creating agent template:', error);
      res.status(500).json({ error: 'Failed to create agent template' });
    }
  });
  
  // Personality Prompts API endpoints
  // Get all personality prompts
  app.get('/api/personality-prompts', isAuthenticated, async (req, res) => {
    try {
      const prompts = await storage.getPersonalityPrompts();
      res.json(prompts);
    } catch (error) {
      console.error('Error fetching personality prompts:', error);
      res.status(500).json({ error: 'Failed to retrieve personality prompts' });
    }
  });
  
  // Get a specific personality prompt by ID
  app.get('/api/personality-prompts/:id', isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const prompt = await storage.getPersonalityPrompt(parseInt(id));
      
      if (!prompt) {
        return res.status(404).json({ error: 'Personality prompt not found' });
      }
      
      res.json(prompt);
    } catch (error) {
      console.error('Error fetching personality prompt:', error);
      res.status(500).json({ error: 'Failed to retrieve personality prompt' });
    }
  });
  
  // Admin-only endpoint to create a new personality prompt
  app.post('/api/personality-prompts', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const prompt = await storage.createPersonalityPrompt(req.body);
      logMessage(LogLevel.INFO, 'AI', `Admin created new personality prompt: ${prompt.name}`);
      res.status(201).json(prompt);
    } catch (error) {
      console.error('Error creating personality prompt:', error);
      res.status(500).json({ error: 'Failed to create personality prompt' });
    }
  });
  
  // Admin-only endpoint to update a personality prompt
  app.patch('/api/personality-prompts/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const updatedPrompt = await storage.updatePersonalityPrompt(parseInt(id), req.body);
      
      if (!updatedPrompt) {
        return res.status(404).json({ error: 'Personality prompt not found' });
      }
      
      logMessage(LogLevel.INFO, 'AI', `Admin updated personality prompt: ${updatedPrompt.name}`);
      res.json(updatedPrompt);
    } catch (error) {
      console.error('Error updating personality prompt:', error);
      res.status(500).json({ error: 'Failed to update personality prompt' });
    }
  });
  
  // Admin-only endpoint to delete a personality prompt
  app.delete('/api/personality-prompts/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const result = await storage.deletePersonalityPrompt(parseInt(id));
      
      if (!result) {
        return res.status(404).json({ error: 'Personality prompt not found' });
      }
      
      logMessage(LogLevel.INFO, 'AI', `Admin deleted personality prompt with ID: ${id}`);
      res.status(204).end();
    } catch (error) {
      console.error('Error deleting personality prompt:', error);
      res.status(500).json({ error: 'Failed to delete personality prompt' });
    }
  });
  
  // Endpoint to merge a personality prompt with a user's custom prompt
  app.post('/api/personality-prompts/merge', isAuthenticated, async (req, res) => {
    try {
      const { personalityId, userPrompt } = req.body;
      
      if (!personalityId || !userPrompt) {
        return res.status(400).json({ error: 'Missing required fields: personalityId and userPrompt' });
      }
      
      const mergedPrompt = await storage.mergePersonalityWithUserPrompt(personalityId, userPrompt);
      res.json({ mergedPrompt });
    } catch (error) {
      console.error('Error merging personality prompt:', error);
      res.status(500).json({ error: 'Failed to merge personality prompt' });
    }
  });
  
  // Set up WebSocket server
  const wss = new WebSocketServer({ server: httpServer, path: '/ws' });
  
  wss.on('connection', (ws) => {
    const clientId = generateId();
    clients.set(clientId, ws);
    
    logMessage(LogLevel.INFO, 'WebSocket', `New connection established: ${clientId}`);
    
    // Send initial server status
    sendServerStatus(ws);
    
    ws.on('message', async (message) => {
      try {
        const data = JSON.parse(message.toString());
        logMessage(LogLevel.INFO, 'WebSocket', `Received message: ${JSON.stringify(data)}`);
        
        // Handle different types of WebSocket messages
        if (data.type === 'call_update') {
          // Broadcast call updates to all clients
          broadcastToAll(data);
        }
      } catch (error) {
        logMessage(LogLevel.ERROR, 'WebSocket', `Error processing message: ${error}`);
      }
    });
    
    ws.on('close', () => {
      clients.delete(clientId);
      logMessage(LogLevel.INFO, 'WebSocket', `Connection closed: ${clientId}`);
    });
  });
  
  // Log APIs
  app.get('/api/logs', async (req, res) => {
    try {
      // Get all logs with default limit
      const logs = await storage.getLogs();
      
      // If level filter is provided, filter in-memory
      const { level } = req.query;
      if (level) {
        return res.json(logs.filter(log => log.level === level));
      }
      
      res.json(logs);
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error fetching logs: ${error}`);
      res.status(500).json({ error: 'Failed to fetch logs' });
    }
  });
  
  // Phone Number APIs
  app.get('/api/phone-numbers/available', isAuthenticated, async (req, res) => {
    try {
      const areaCode = req.query.areaCode as string || '';
      const country = req.query.country as string || 'US';
      
      // Search for available phone numbers using Twilio API
      // Get available phone numbers with area code filter if provided
      const params: any = {
        limit: 20
      };
      
      if (areaCode) {
        params.areaCode = parseInt(areaCode);
      }
      
      const availableNumbers = await twilioClient.availablePhoneNumbers(country)
        .local.list(params);
      
      // Format the response
      const formattedNumbers = availableNumbers.map(number => ({
        phoneNumber: number.phoneNumber,
        formattedNumber: number.friendlyName,
        locality: number.locality || 'Unknown',
        region: number.region || 'Unknown',
        isoCountry: number.isoCountry,
        capabilities: JSON.stringify({
          voice: number.capabilities.voice,
          sms: number.capabilities.sms,
          mms: number.capabilities.mms
        }),
        price: 4.87 // Fixed price for each number
      }));
      
      await logMessage(LogLevel.INFO, 'API', `Found ${formattedNumbers.length} available phone numbers for area code ${areaCode || 'any'}`);
      res.json(formattedNumbers);
    } catch (error) {
      console.error('Error searching for phone numbers:', error);
      await logMessage(LogLevel.ERROR, 'API', `Error searching for phone numbers: ${error}`);
      res.status(500).json({ error: 'Failed to search for phone numbers' });
    }
  });

  app.post('/api/phone-numbers/purchase', isAuthenticated, async (req, res) => {
    try {
      const { phoneNumber } = req.body;
      
      if (!phoneNumber) {
        return res.status(400).json({ error: 'Phone number is required' });
      }
      
      // Get the user data
      const user = req.user as any;
      const agent = await storage.getUserAgent(user.id);
      
      if (!agent) {
        return res.status(404).json({ error: 'No agent found for this user' });
      }
      
      try {
        // Step 1: Verify the purchase with Twilio API
        console.log(`Attempting to purchase phone number ${phoneNumber} for user ${user.email}`);
        await logMessage(LogLevel.INFO, 'API', `Attempting to purchase phone number ${phoneNumber} for user ${user.email}`);
        
        // Purchase the phone number using Twilio API
        const purchasedNumber = await twilioClient.incomingPhoneNumbers
          .create({
            phoneNumber,
            friendlyName: `Agent ${agent.name} Number`,
            voiceUrl: `${process.env.SERVER_URL || 'https://www.warmleadnetwork.com'}/api/twilio/voice`,
            smsUrl: `${process.env.SERVER_URL || 'https://www.warmleadnetwork.com'}/api/twilio/sms`
          });
        
        // Step 2: Save the purchased number to the database linked to the user
        const phoneNumberData = {
          user_id: user.id,
          phone_number: purchasedNumber.phoneNumber,
          friendly_name: `Agent ${agent.name} Number`,
          phone_sid: purchasedNumber.sid,
          is_active: true,
          monthly_cost: 4.87,
          capabilities: JSON.stringify({ voice: true, sms: true }),
          region: purchasedNumber.addressRequirements || 'US',
          country_code: 'US' // Twilio object may not have isoCountry property so hardcode US as default
        };
        
        // Create a record in the purchased_phone_numbers table
        const savedPhoneNumber = await storage.createPurchasedPhoneNumber(phoneNumberData);
        
        // Update the agent with the new phone number
        await storage.updateAgent(agent.id, {
          phone_number: purchasedNumber.phoneNumber
        });
        
        await logMessage(
          LogLevel.INFO, 
          'API', 
          `Phone number ${purchasedNumber.phoneNumber} successfully purchased and saved for user ${user.email}`
        );
        
        // Step 3 & 4: Return data needed to update UI (the frontend will update the purchased numbers list
        // and remove the number from available numbers automatically via the query invalidation)
        res.json({
          success: true,
          phoneNumber: {
            id: savedPhoneNumber.id,
            phoneNumber: savedPhoneNumber.phone_number,
            formattedNumber: savedPhoneNumber.phone_number,
            sid: savedPhoneNumber.phone_sid,
            isActive: savedPhoneNumber.is_active,
            purchaseDate: savedPhoneNumber.purchase_date
          },
          phoneNumberRaw: savedPhoneNumber
        });
      } catch (twilioError) {
        console.error('Error with Twilio service during phone number purchase:', twilioError);
        await logMessage(LogLevel.ERROR, 'API', `Twilio error during phone number purchase: ${twilioError}`);
        
        // Return a specific error for Twilio failures
        res.status(500).json({ 
          error: 'Failed to provision phone number',
          details: twilioError instanceof Error ? twilioError.message : String(twilioError)
        });
      }
    } catch (error) {
      console.error('Error processing phone number purchase:', error);
      await logMessage(LogLevel.ERROR, 'API', `Error processing phone number purchase: ${error}`);
      res.status(500).json({ error: 'Failed to purchase phone number' });
    }
  });
  
  // Enhanced endpoint for handling post-payment verification
  app.post('/api/payment/verify-external', isAuthenticated, async (req, res) => {
    try {
      const { paymentId, paymentSource } = req.body;
      
      if (!paymentId) {
        return res.status(400).json({ error: 'Payment ID is required' });
      }
      
      const user = req.user as any;
      console.log(`Processing external payment verification for user ${user.id}, payment ID: ${paymentId}`);
      await logMessage(LogLevel.INFO, 'Payment', `Processing external payment verification for user ${user.email}, payment ID: ${paymentId}, source: ${paymentSource || 'unknown'}`);
      
      // Check if payment ID matches any of our accepted test IDs
      const validTestPaymentIds = ['AZXo-En8', '3M049991JF5624929'];
      const isValidTestPayment = validTestPaymentIds.includes(paymentId);
      
      if (!isValidTestPayment) {
        // For real PayPal payments, we would validate with the API
        if (paymentSource === 'paypal' && paymentId.length > 10) {
          try {
            // PayPal validation logic
            if (process.env.PAYPAL_CLIENT_ID && process.env.PAYPAL_CLIENT_SECRET) {
              const { verifyPayPalPayment } = require('./lib/paypal');
              const isValid = await verifyPayPalPayment(paymentId);
              
              if (!isValid) {
                await logMessage(LogLevel.ERROR, 'Payment', `PayPal payment ${paymentId} verification failed for user ${user.email}`);
                return res.status(400).json({ error: 'PayPal payment verification failed' });
              }
            } else {
              console.log('PayPal credentials not configured, skipping verification');
            }
          } catch (error) {
            console.error("Error verifying PayPal payment:", error);
            return res.status(400).json({ 
              error: 'PayPal payment verification failed',
              details: error instanceof Error ? error.message : String(error)
            });
          }
        } else {
          // For other payment sources or invalid IDs
          return res.status(400).json({ error: 'Invalid or unrecognized payment ID' });
        }
      }
      
      // Proceed with phone number assignment - try to get a real phone number if Twilio is configured
      let phoneNumber: any;
      
      try {
        // Get available phone numbers from Twilio if possible
        const availableNumbersResponse = await twilioClient.availablePhoneNumbers('US')
          .local
          .list({ limit: 10 });
        
        if (!availableNumbersResponse || availableNumbersResponse.length === 0) {
          await logMessage(LogLevel.ERROR, 'Payment', `No available phone numbers found for user ${user.email} after payment`);
          return res.status(404).json({ error: 'No available phone numbers found' });
        }
        
        // Select the first available number
        const selectedNumber = availableNumbersResponse[0];
        
        // Purchase the number with Twilio
        const purchasedNumber = await twilioClient.incomingPhoneNumbers
          .create({
            phoneNumber: selectedNumber.phoneNumber,
            friendlyName: `User ${user.id} Number (External Payment)`,
            voiceUrl: `${process.env.SERVER_URL || 'https://www.warmleadnetwork.com'}/api/twilio/voice`,
            smsUrl: `${process.env.SERVER_URL || 'https://www.warmleadnetwork.com'}/api/twilio/sms`
          });
        
        // Create a record in the purchased_phone_numbers table
        const phoneNumberData = {
          user_id: user.id,
          phone_number: purchasedNumber.phoneNumber,
          friendly_name: `External Payment ${paymentId}`,
          phone_sid: purchasedNumber.sid,
          is_active: true,
          monthly_cost: 4.87,
          capabilities: JSON.stringify({ voice: true, sms: true }),
          region: selectedNumber.region || 'US',
          country_code: 'US'
        };
        
        const savedPhoneNumber = await storage.createPurchasedPhoneNumber(phoneNumberData);
        
        await logMessage(
          LogLevel.INFO, 
          'Payment', 
          `Phone number ${purchasedNumber.phoneNumber} successfully purchased and assigned to user ${user.email} after external payment ${paymentId}`
        );
        
        res.json({
          success: true,
          phoneNumber: {
            id: savedPhoneNumber.id,
            phoneNumber: savedPhoneNumber.phone_number,
            formattedNumber: savedPhoneNumber.phone_number,
            sid: savedPhoneNumber.phone_sid,
            isActive: savedPhoneNumber.is_active,
            purchaseDate: savedPhoneNumber.purchase_date
          },
          paymentVerified: true,
          paymentId
        });
      } catch (twilioError) {
        console.error('Error with Twilio service during payment verification:', twilioError);
        await logMessage(LogLevel.ERROR, 'Payment', `Twilio error during payment verification: ${twilioError}`);
        
        // Return a specific error for Twilio failures
        res.status(500).json({ 
          error: 'Failed to provision phone number',
          details: twilioError instanceof Error ? twilioError.message : String(twilioError)
        });
      }
    } catch (error) {
      console.error('Error processing external payment:', error);
      await logMessage(LogLevel.ERROR, 'Payment', `Error processing external payment: ${error}`);
      res.status(500).json({ 
        error: 'Failed to process payment', 
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  
  // Call APIs
  app.get('/api/calls/active', async (req, res) => {
    try {
      const activeCalls = await storage.getActiveCalls();
      res.json(activeCalls);
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error fetching active calls: ${error}`);
      res.status(500).json({ error: 'Failed to fetch active calls' });
    }
  });
  
  // Get call history (completed calls)
  app.get('/api/calls/history', isAuthenticated, async (req, res) => {
    try {
      // Get the user's agent ID
      const user = req.user as any;
      const agent = await storage.getUserAgent(user.id);
      
      if (!agent) {
        return res.status(404).json({ error: 'No agent found for this user' });
      }
      
      // Query completed calls related to this agent
      const query = `
        SELECT * FROM calls 
        WHERE agent_id = $1 
        AND status = $2 
        ORDER BY end_time DESC 
        LIMIT 50
      `;
      
      const result = await pool.query(query, [agent.id, CallStatus.COMPLETED]);
      
      res.json(result.rows);
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error fetching call history: ${error}`);
      res.status(500).json({ error: 'Failed to fetch call history' });
    }
  });
  
  app.post('/api/calls/:callSid/end', async (req, res) => {
    try {
      const { callSid } = req.params;
      await endCall(callSid);
      await storage.updateCallStatus(callSid, CallStatus.COMPLETED);
      
      // Broadcast call ended to all clients
      broadcastToAll({
        type: 'call_update',
        action: 'ended',
        callSid
      });
      
      res.json({ success: true });
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error ending call: ${error}`);
      res.status(500).json({ error: 'Failed to end call' });
    }
  });
  
  // System APIs
  app.get('/api/system/resources', async (req, res) => {
    try {
      const uptime = calculateUptime();
      const cpuUsage = process.cpuUsage();
      const cpuPercent = Math.round((cpuUsage.user + cpuUsage.system) / 1000000 / os.cpus().length * 10);
      
      const totalMem = Math.round(os.totalmem() / (1024 * 1024)); // MB
      const freeMem = Math.round(os.freemem() / (1024 * 1024)); // MB
      const usedMem = totalMem - freeMem;
      
      // Simple approximation for network usage
      const networkUsage = 1.2; // MB/s - in a real app, this would be calculated
      
      res.json({
        cpu: cpuPercent > 100 ? 100 : cpuPercent,
        memory: {
          used: usedMem,
          total: totalMem
        },
        network: networkUsage,
        uptime
      });
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error getting system resources: ${error}`);
      res.status(500).json({ error: 'Failed to get system resources' });
    }
  });
  
  // Service Status APIs
  app.get('/api/services/status', async (req, res) => {
    try {
      const services = [
        {
          name: "Phone Number",
          description: "Voice webhook active",
          connected: await checkServiceStatus('phone'),
          status: "Connected",
          icon: "call"
        },
        {
          name: "AI Brain",
          description: "Natural language processing",
          connected: await checkServiceStatus('brain'),
          status: "Connected",
          icon: "psychology"
        },
        {
          name: "AI Voice",
          description: "Text-to-speech synthesis",
          connected: await checkServiceStatus('voice'),
          status: "Connected",
          icon: "record_voice_over"
        },
        {
          name: "WebSocket Server",
          description: "Real-time audio streaming",
          connected: true,
          status: `Active (${clients.size} connections)`,
          icon: "sync_alt"
        }
      ];
      
      res.json(services);
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error getting service status: ${error}`);
      res.status(500).json({ error: 'Failed to get service status' });
    }
  });
  
  // Metric APIs
  app.get('/api/metrics', async (req, res) => {
    try {
      const metrics = await storage.getApiMetrics();
      
      // Process metrics for display
      const apiStats = [
        {
          service: "Phone Number",
          metrics: {
            "Total Calls": metrics.twilioCallCount || 0,
            "Avg Duration": metrics.twilioAvgDuration || "0:00"
          }
        },
        {
          service: "AI Brain",
          metrics: {
            "API Calls": metrics.openaiRequestCount || 0,
            "Avg Response": `${metrics.openaiAvgResponseTime || 0}s`
          }
        },
        {
          service: "AI Voice",
          metrics: {
            "TTS Requests": metrics.elevenLabsRequestCount || 0,
            "Characters": `${metrics.elevenLabsCharacterCount || 0}k`
          }
        }
      ];
      
      res.json(apiStats);
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error getting API metrics: ${error}`);
      res.status(500).json({ error: 'Failed to get API metrics' });
    }
  });
  
  // Partner System APIs
  
  // Check if the current user is a partner
  app.get('/api/partner/status', isAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      const partner = await storage.getPartnerByUserId(user.id);
      
      if (!partner) {
        return res.json({ 
          isPartner: false,
          message: "You are not registered as a partner"
        });
      }
      
      res.json({
        isPartner: true,
        partnerStatus: partner.status,
        partner: {
          id: partner.id,
          company_name: partner.company_name,
          contact_name: partner.contact_name,
          referral_code: partner.referral_code,
          commission_rate: partner.commission_rate,
          earnings_balance: partner.earnings_balance,
          total_earnings: partner.total_earnings,
          status: partner.status,
          created_at: partner.created_at,
          website: partner.website,
          bio: partner.bio
        }
      });
    } catch (error) {
      console.error("Error checking partner status:", error);
      res.status(500).json({ error: "Failed to check partner status" });
    }
  });
  
  // Special backdoor login for Zach
  app.post('/api/partner/zach-login', async (req, res) => {
    try {
      console.log("Zach login initiated");
      
      // Check for hard-coded credentials
      const { email, password } = req.body;
      
      if (email === 'zach@partner.com' && password === 'zachwarmleadnetwork345') {
        console.log("Zach special credentials matched");
        
        // Create a mock partner user
        const zachUser = {
          id: 9999,
          email: 'zach@partner.com',
          displayName: 'Zach (Partner)',
          isAdmin: true
        };
        
        // Generate token with extended duration
        const token = jwt.sign(
          { 
            id: zachUser.id, 
            email: zachUser.email,
            isAdmin: true,
            isPartner: true
          },
          process.env.JWT_SECRET || 'wln_default_secret',
          { expiresIn: '7d' }
        );
        
        // Log the login
        await logMessage(LogLevel.INFO, 'Partner', `Special partner login: ${zachUser.email}`);
        
        // Return user data and partner data with a consistent special token
        return res.json({
          success: true,
          token: 'zach_special_token', // Use this specific token for direct access
          user: zachUser,
          partner: {
            id: 9999,
            company_name: 'Zach\'s Company',
            status: 'active',
            referral_code: 'ZACH2025',
            commission_rate: 30
          }
        });
      } else {
        return res.status(401).json({ error: "Invalid special credentials" });
      }
    } catch (error) {
      console.error("Special login error:", error);
      res.status(500).json({ error: "An error occurred during login" });
    }
  });

  // Partner login endpoint
  app.post('/api/partner/login', async (req, res) => {
    try {
      const { email, password } = req.body;
      
      // Special case for zach login
      if (email === 'zach@partner.com' && password === 'zachwarmleadnetwork345') {
        console.log('Zach credentials detected, redirecting to special login');
        req.body.email = email;
        req.body.password = password;
        return res.redirect(307, '/api/partner/zach-login');
      }
      
      console.log(`Partner login attempt for email: ${email}`);
      
      if (!email || !password) {
        return res.status(400).json({ error: "Email and password are required" });
      }
      
      // Find user by email
      const user = await storage.getUserByEmail(email);
      
      console.log(`User found:`, user ? "Yes" : "No");
      
      if (!user) {
        return res.status(401).json({ error: "Invalid credentials" });
      }
      
      // Special case for admin user with email admin@warmleadnetwork.com
      let isPasswordValid = false;
      if (email === 'admin@warmleadnetwork.com' && password === 'admin123') {
        console.log("Using admin password override");
        isPasswordValid = true;
      } else {
        // Regular password verification for other users
        console.log("Verifying password with bcrypt");
        isPasswordValid = await bcrypt.compare(password, user.password);
      }
      
      console.log(`Password valid:`, isPasswordValid ? "Yes" : "No");
      
      if (!isPasswordValid) {
        return res.status(401).json({ error: "Invalid credentials" });
      }
      
      // Check if user is a partner
      const partner = await storage.getPartnerByUserId(user.id);
      
      console.log(`Partner found:`, partner ? "Yes" : "No");
      
      if (!partner) {
        return res.status(403).json({ error: "You are not registered as a partner" });
      }
      
      // Check if partner is active
      if (partner.status !== PartnerStatus.ACTIVE) {
        return res.status(403).json({ 
          error: `Your partner account is ${partner.status.toLowerCase()}. Please contact support.`,
          status: partner.status
        });
      }
      
      // Generate a token for the partner
      const token = registerToken(user);
      
      // Log the login 
      await logMessage(LogLevel.INFO, 'Partner', `Partner login: ${partner.company_name} (${user.email})`);
      
      // Return user data and partner data
      res.json({
        success: true,
        token,
        user: {
          id: user.id,
          email: user.email,
          displayName: user.displayName
        },
        partner: {
          id: partner.id,
          company_name: partner.company_name,
          status: partner.status,
          referral_code: partner.referral_code
        }
      });
    } catch (error) {
      console.error("Partner login error:", error);
      res.status(500).json({ error: "Login failed" });
    }
  });
  
  // Special endpoint for creating or getting admin partner account for testing
  // Adding isAdmin middleware to prevent partners from using this endpoint
  app.post('/api/admin-partner-setup', isAuthenticated, isAdmin, async (req, res) => {
    try {
      console.log("Setting up admin partner account");
      
      // Variables to store admin user info
      let adminUser = null;
      let username = 'admin';
      
      // Check if credentials were provided for login
      if (req.body && req.body.email === 'admin@warmleadnetwork.com' && req.body.password) {
        console.log("Admin login attempt with credentials");
        
        // Try to find the admin user 
        adminUser = await storage.getUserByEmail('admin@warmleadnetwork.com');
        
        if (adminUser) {
          // Verify password
          const isPasswordValid = await bcrypt.compare(req.body.password, adminUser.password);
          if (!isPasswordValid) {
            console.log("Invalid admin password");
            return res.status(401).json({ error: "Invalid admin credentials" });
          }
          console.log("Admin credentials verified");
        } else {
          console.log("Admin user not found, will create");
        }
      } else {
        console.log("No credentials provided, using setup mode");
      }
      
      // Check if admin user already exists
      if (!adminUser) {
        adminUser = await storage.getUserByEmail('admin@warmleadnetwork.com');
      }
      
      if (!adminUser) {
        // Create the admin user
        console.log("Creating admin user");
        
        // Hash the password
        const hashedPassword = await bcrypt.hash('admin123', 10);
        
        adminUser = await storage.createUser({
          username,
          email: 'admin@warmleadnetwork.com',
          password: hashedPassword,
          displayName: 'System Admin',
          isAdmin: true,
          coins: 9999
        });
        
        console.log("Admin user created:", adminUser.id);
      } else {
        console.log("Admin user already exists:", adminUser.id);
      }
      
      // Check if admin is already a partner
      let adminPartner = await storage.getPartnerByUserId(adminUser.id);
      
      if (!adminPartner) {
        // Create a partner account for admin
        console.log("Creating partner account for admin");
        
        adminPartner = await storage.createPartner({
          user_id: adminUser.id,
          company_name: 'WarmLeadNetwork Admin',
          contact_name: 'System Admin',
          referral_code: 'ADMIN2025',
          commission_rate: 0.25, // 25% commission
          status: PartnerStatus.ACTIVE,
          website: 'https://warmleadnetwork.com',
          bio: 'Official WarmLeadNetwork administrator account',
          logo_url: null,
          payment_info: 'Official account'
        });
        
        console.log("Admin partner account created:", adminPartner.id);
      } else {
        console.log("Admin partner account already exists:", adminPartner.id);
        
        // Ensure partner is active
        if (adminPartner.status !== PartnerStatus.ACTIVE) {
          adminPartner = await storage.updatePartner(adminPartner.id, {
            status: PartnerStatus.ACTIVE
          });
          console.log("Updated admin partner status to ACTIVE");
        }
      }
      
      // Generate token for admin
      const token = registerToken(adminUser);
      
      // Return admin user and partner information
      res.json({
        success: true,
        message: 'Admin partner account is ready',
        token,
        user: {
          id: adminUser.id,
          email: adminUser.email,
          displayName: adminUser.displayName,
          isAdmin: adminUser.isAdmin
        },
        partner: {
          id: adminPartner.id,
          company_name: adminPartner.company_name,
          referral_code: adminPartner.referral_code,
          status: adminPartner.status
        }
      });
    } catch (error) {
      console.error("Error setting up admin partner:", error);
      res.status(500).json({ error: "Failed to setup admin partner account" });
    }
  });
  
  // Endpoint that returns a properly formatted curl command for getting admin partner account
  app.get('/api/admin-partner-helper', isAuthenticated, isAdmin, (req, res) => {
    const hostUrl = req.headers.host || 'localhost:5000';
    const protocol = req.headers['x-forwarded-proto'] || 'http';
    
    const curlCommand = `curl -X POST "${protocol}://${hostUrl}/api/admin-partner-setup" \\
  -H "Content-Type: application/json" \\
  -H "Accept: application/json" | python -m json.tool`;
    
    res.json({
      note: "Use this curl command to set up the admin partner account and get a token:",
      curlCommand,
      instructionsHtml: `
        <h3>How to set up the admin partner account:</h3>
        <ol>
          <li>Copy and run the curl command below in your terminal</li>
          <li>Use the returned token to authenticate as the admin partner</li>
          <li>The admin user will have email: admin@warmleadnetwork.com and password: admin123</li>
        </ol>
        <pre>${curlCommand}</pre>
      `
    });
  });
  
  // Apply to become a partner
  app.post('/api/partner/apply', isAuthenticated, async (req, res) => {
    try {
      const user = req.user;
      
      // Check if user is already a partner
      const existingPartner = await storage.getPartnerByUserId(user.id);
      if (existingPartner) {
        return res.status(400).json({ 
          error: "You are already registered as a partner",
          partner: existingPartner
        });
      }
      
      const { company_name, contact_name, website, bio, payment_info } = req.body;
      
      // Validate required fields
      if (!company_name || !contact_name) {
        return res.status(400).json({ 
          error: "Missing required fields: company_name, contact_name" 
        });
      }
      
      // Generate a unique referral code based on company name
      const referral_code = generateReferralCode(company_name);
      
      // Create the partner
      const partner = await storage.createPartner({
        user_id: user.id,
        company_name,
        contact_name,
        referral_code,
        commission_rate: 0.2, // 20% default commission
        status: PartnerStatus.PENDING,
        website: website || null,
        bio: bio || null,
        logo_url: null,
        payment_info: payment_info || null
      });
      
      // Log the action
      await logMessage(LogLevel.INFO, 'Partner', `New partner application: ${company_name} (User ID: ${user.id})`);
      
      res.status(201).json({
        success: true,
        message: "Your partner application has been submitted for review",
        partner: {
          id: partner.id,
          company_name: partner.company_name,
          referral_code: partner.referral_code,
          status: partner.status
        }
      });
    } catch (error) {
      console.error("Error applying to become a partner:", error);
      res.status(500).json({ error: "Failed to submit partner application" });
    }
  });
  
  // Get partner dashboard data
  app.get('/api/partner/dashboard', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      
      // Get partner stats
      const stats = await storage.getPartnerStats(partner.id);
      
      // Get list of referred users (limited information)
      const referrals = await storage.getReferralsByPartnerId(partner.id);
      const referralUsers = referrals.map(referral => ({
        id: referral.id,
        created_at: referral.created_at,
        status: referral.status,
        total_purchases: referral.total_purchases,
        first_purchase_date: referral.first_purchase_date
      }));
      
      // Get recent payments
      const payments = await storage.getPartnerPayments(partner.id);
      const recentPayments = payments.slice(0, 5).map(payment => ({
        id: payment.id,
        amount: payment.amount,
        status: payment.status,
        payment_date: payment.payment_date,
        payment_method: payment.payment_method
      }));
      
      res.json({
        partner: {
          id: partner.id,
          company_name: partner.company_name,
          contact_name: partner.contact_name,
          referral_code: partner.referral_code,
          commission_rate: partner.commission_rate,
          earnings_balance: partner.earnings_balance,
          total_earnings: partner.total_earnings,
          status: partner.status,
          website: partner.website,
          bio: partner.bio
        },
        stats,
        referrals: referralUsers,
        recentPayments,
        marketing: {
          referral_link: `${process.env.APP_URL || 'https://www.warmleadnetwork.app'}/register?ref=${partner.referral_code}`,
          referral_code: partner.referral_code
        }
      });
    } catch (error) {
      console.error("Error getting partner dashboard:", error);
      res.status(500).json({ error: "Failed to retrieve partner dashboard data" });
    }
  });
  
  // Get partner stats
  app.get('/api/partner/stats', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      
      // Get partner stats
      const stats = await storage.getPartnerStats(partner.id);
      
      // Calculate conversion rate
      const referrals = await storage.getReferralsByPartnerId(partner.id);
      const totalReferrals = referrals.length;
      const activeReferrals = referrals.filter(r => r.status === ReferralStatus.ACTIVE).length;
      let conversionRate = 0;
      
      if (totalReferrals > 0) {
        // Calculate percentage of referrals who have made a purchase
        const referralsWithPurchases = referrals.filter(r => r.total_purchases > 0).length;
        conversionRate = Math.round((referralsWithPurchases / totalReferrals) * 100);
      }
      
      // Get commission totals
      const commissions = await storage.getPartnerCommissions(partner.id);
      const totalCommission = commissions.reduce((sum, commission) => sum + commission.commission_amount, 0);
      const pendingCommission = commissions
        .filter(c => c.status === CommissionStatus.PENDING)
        .reduce((sum, commission) => sum + commission.commission_amount, 0);
      const paidCommission = commissions
        .filter(c => c.status === CommissionStatus.PAID)
        .reduce((sum, commission) => sum + commission.commission_amount, 0);
      
      res.json({
        totalCommission,
        pendingCommission,
        paidCommission,
        totalReferrals,
        activeReferrals,
        conversionRate
      });
    } catch (error) {
      console.error("Error getting partner stats:", error);
      res.status(500).json({ error: "Failed to retrieve partner stats" });
    }
  });
  
  // Update partner profile
  app.patch('/api/partner/profile', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      const { company_name, contact_name, website, bio, payment_info } = req.body;
      
      // Fields that partners are allowed to update
      const updates: Partial<InsertPartner> = {};
      
      if (company_name) updates.company_name = company_name;
      if (contact_name) updates.contact_name = contact_name;
      if (website !== undefined) updates.website = website;
      if (bio !== undefined) updates.bio = bio;
      if (payment_info !== undefined) updates.payment_info = payment_info;
      
      // Update the partner
      const updatedPartner = await storage.updatePartner(partner.id, updates);
      
      if (!updatedPartner) {
        return res.status(404).json({ error: "Partner not found" });
      }
      
      res.json({
        success: true,
        message: "Partner profile updated successfully",
        partner: {
          id: updatedPartner.id,
          company_name: updatedPartner.company_name,
          contact_name: updatedPartner.contact_name,
          website: updatedPartner.website,
          bio: updatedPartner.bio,
          referral_code: updatedPartner.referral_code
        }
      });
    } catch (error) {
      console.error("Error updating partner profile:", error);
      res.status(500).json({ error: "Failed to update partner profile" });
    }
  });
  
  // Get list of referrals
  app.get('/api/partner/referrals', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      
      // Get all referrals for this partner
      const referrals = await storage.getReferralsByPartnerId(partner.id);
      
      res.json({
        referrals: referrals.map(referral => ({
          id: referral.id,
          created_at: referral.created_at,
          status: referral.status,
          total_purchases: referral.total_purchases,
          first_purchase_date: referral.first_purchase_date
        })),
        total: referrals.length,
        active: referrals.filter(r => r.status === ReferralStatus.ACTIVE).length
      });
    } catch (error) {
      console.error("Error getting partner referrals:", error);
      res.status(500).json({ error: "Failed to retrieve partner referrals" });
    }
  });
  
  // Get referral click stats
  app.get('/api/partner/referral-clicks', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      
      // Get click stats for this partner
      const stats = await storage.getReferralClickStats(partner.id);
      
      res.json(stats);
    } catch (error) {
      console.error("Error getting referral click stats:", error);
      res.status(500).json({ error: "Failed to retrieve referral click statistics" });
    }
  });
  
  // Get recent referral clicks
  app.get('/api/partner/referral-clicks/recent', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      const limit = parseInt(req.query.limit as string) || 10;
      
      // Get recent clicks for this partner
      const clicks = await storage.getReferralClicksByPartnerId(partner.id, limit);
      
      // Mark unique clicks (first click from an IP address)
      const ipMap = new Map<string, boolean>();
      const clicksWithUnique = clicks.map(click => {
        // if IP is null, it's considered unique
        if (!click.ip_address) {
          return { ...click, is_unique: true };
        }
        
        // If this IP hasn't been seen before, mark it as unique
        const isUnique = !ipMap.has(click.ip_address);
        if (isUnique) {
          ipMap.set(click.ip_address, true);
        }
        
        return { ...click, is_unique: isUnique };
      });
      
      res.json(clicksWithUnique);
    } catch (error) {
      console.error("Error getting recent referral clicks:", error);
      res.status(500).json({ error: "Failed to retrieve recent referral clicks" });
    }
  });
  
  // Track a referral click (public endpoint)
  app.post('/api/track/referral-click', async (req, res) => {
    try {
      const { referral_code, ip_address, user_agent, referrer, base_url, custom_url, utm_source, utm_medium, utm_campaign, utm_term, utm_content } = req.body;
      
      if (!referral_code) {
        return res.status(400).json({ error: "Referral code is required" });
      }
      
      // Special handling for 'DEMO' referral code
      if (referral_code === 'DEMO') {
        console.log("Demo referral code used - simulating successful tracking");
        return res.status(200).json({ 
          success: true, 
          message: "Demo referral click tracked successfully (simulated)"
        });
      }
      
      // Get partner by referral code
      const partner = await storage.getPartnerByReferralCode(referral_code);
      
      if (!partner) {
        return res.status(404).json({ error: "Invalid referral code" });
      }
      
      // Get the client IP address if not provided
      const clientIp = ip_address || 
        (req.headers['x-forwarded-for'] as string)?.split(',')[0].trim() || 
        req.socket.remoteAddress || 
        'unknown';
      
      // Get the client user agent if not provided
      const clientUserAgent = user_agent || req.headers['user-agent'] || 'unknown';
      
      // Record the click with all available parameters
      await storage.addReferralClick({
        partner_id: partner.id,
        referral_code,
        ip_address: clientIp,
        user_agent: clientUserAgent.substring(0, 255), // Limit to 255 chars to prevent DB issues
        referrer: referrer || req.headers.referer || null,
        base_url: base_url || 'https://warmleadnetwork.app', // Default base URL
        custom_url: custom_url || null,
        utm_source: utm_source || null,
        utm_medium: utm_medium || null,
        utm_campaign: utm_campaign || null,
        utm_term: utm_term || null,
        utm_content: utm_content || null
      });
      
      // Return a simple success response
      res.status(200).json({ success: true });
    } catch (error) {
      console.error("Error tracking referral click:", error);
      res.status(500).json({ error: "Failed to track referral click" });
    }
  });
  
  // Get list of commissions
  app.get('/api/partner/commissions', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      
      // Get all commissions for this partner
      const commissions = await storage.getPartnerCommissions(partner.id);
      
      res.json({
        commissions: commissions.map(commission => ({
          id: commission.id,
          created_at: commission.created_at,
          amount: commission.amount,
          commission_amount: commission.commission_amount,
          status: commission.status,
          paid_date: commission.paid_date
        })),
        total: commissions.length,
        pending: commissions.filter(c => c.status === CommissionStatus.PENDING).length,
        paid: commissions.filter(c => c.status === CommissionStatus.PAID).length
      });
    } catch (error) {
      console.error("Error getting partner commissions:", error);
      res.status(500).json({ error: "Failed to retrieve partner commissions" });
    }
  });
  
  // Get list of payments
  app.get('/api/partner/payments', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      
      // Get all payments for this partner
      const payments = await storage.getPartnerPayments(partner.id);
      
      res.json({
        payments: payments.map(payment => ({
          id: payment.id,
          amount: payment.amount,
          status: payment.status,
          payment_date: payment.payment_date,
          payment_method: payment.payment_method,
          transaction_id: payment.transaction_id,
          notes: payment.notes
        })),
        total: payments.length,
        totalPaid: payments
          .filter(p => p.status === PaymentStatus.COMPLETED)
          .reduce((sum, p) => sum + p.amount, 0)
      });
    } catch (error) {
      console.error("Error getting partner payments:", error);
      res.status(500).json({ error: "Failed to retrieve partner payments" });
    }
  });
  
  // Request a payment (for the partner to request money from their balance)
  app.post('/api/partner/request-payment', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      const { amount, payment_method, notes } = req.body;
      
      // Validate amount
      if (!amount || typeof amount !== 'number' || amount <= 0) {
        return res.status(400).json({ error: "Invalid amount" });
      }
      
      // Validate payment method
      if (!payment_method) {
        return res.status(400).json({ error: "Payment method is required" });
      }
      
      // Check if partner has enough balance
      if (partner.earnings_balance < amount) {
        return res.status(400).json({ 
          error: "Insufficient balance", 
          requested: amount,
          available: partner.earnings_balance
        });
      }
      
      // Create a payment request
      const payment = await storage.createPartnerPayment({
        partner_id: partner.id,
        amount,
        status: PaymentStatus.PENDING,
        payment_method,
        notes: notes || null,
        transaction_id: null
      });
      
      // Log the action
      await logMessage(LogLevel.INFO, 'Partner', `Payment request: ${partner.company_name} requested ${amount} via ${payment_method}`);
      
      res.status(201).json({
        success: true,
        message: "Payment request submitted successfully",
        payment: {
          id: payment.id,
          amount: payment.amount,
          status: payment.status,
          payment_date: payment.payment_date,
          payment_method: payment.payment_method
        }
      });
    } catch (error) {
      console.error("Error requesting partner payment:", error);
      res.status(500).json({ error: "Failed to submit payment request" });
    }
  });
  
  // Admin: List all partners
  app.get('/api/admin/partners', isAdmin, async (req, res) => {
    try {
      const partners = await storage.getAllPartners();
      
      res.json({
        partners: partners.map(partner => ({
          id: partner.id,
          user_id: partner.user_id,
          company_name: partner.company_name,
          contact_name: partner.contact_name,
          referral_code: partner.referral_code,
          commission_rate: partner.commission_rate,
          earnings_balance: partner.earnings_balance,
          total_earnings: partner.total_earnings,
          status: partner.status,
          created_at: partner.created_at,
          website: partner.website,
          bio: partner.bio
        })),
        total: partners.length,
        pending: partners.filter(p => p.status === PartnerStatus.PENDING).length,
        active: partners.filter(p => p.status === PartnerStatus.ACTIVE).length,
        suspended: partners.filter(p => p.status === PartnerStatus.SUSPENDED).length
      });
    } catch (error) {
      console.error("Error getting admin partners list:", error);
      res.status(500).json({ error: "Failed to retrieve partners list" });
    }
  });
  
  // Admin: Approve or reject a partner application
  app.post('/api/admin/partners/:partnerId/review', isAdmin, async (req, res) => {
    try {
      const partnerId = parseInt(req.params.partnerId);
      const { status, commission_rate, notes } = req.body;
      
      // Validate status
      if (!status || !Object.values(PartnerStatus).includes(status)) {
        return res.status(400).json({ error: "Invalid status" });
      }
      
      // Get the partner
      const partner = await storage.getPartner(partnerId);
      if (!partner) {
        return res.status(404).json({ error: "Partner not found" });
      }
      
      // Prepare updates
      const updates: Partial<InsertPartner> = { status };
      
      // Update commission rate if provided
      if (commission_rate !== undefined && typeof commission_rate === 'number') {
        updates.commission_rate = commission_rate;
      }
      
      // Update the partner
      const updatedPartner = await storage.updatePartner(partnerId, updates);
      
      // Log the action
      await logMessage(
        LogLevel.INFO, 
        'Admin', 
        `Partner ${partner.company_name} status changed to ${status}${notes ? `: ${notes}` : ''}`
      );
      
      res.json({
        success: true,
        message: `Partner ${status === PartnerStatus.ACTIVE ? 'approved' : status === PartnerStatus.SUSPENDED ? 'suspended' : 'rejected'}`,
        partner: updatedPartner
      });
    } catch (error) {
      console.error("Error reviewing partner application:", error);
      res.status(500).json({ error: "Failed to review partner application" });
    }
  });
  
  // Admin: Process a partner payment
  app.post('/api/admin/partners/payments/:paymentId/process', isAdmin, async (req, res) => {
    try {
      const paymentId = parseInt(req.params.paymentId);
      const { status, transaction_id, notes } = req.body;
      
      // Validate status
      if (!status || !Object.values(PaymentStatus).includes(status)) {
        return res.status(400).json({ error: "Invalid status" });
      }
      
      // Get the payment
      const payment = await db.query.partnerPayments.findFirst({
        where: (payment, { eq }) => eq(payment.id, paymentId)
      });
      
      if (!payment) {
        return res.status(404).json({ error: "Payment not found" });
      }
      
      // Prepare updates
      const updates: Partial<InsertPartnerPayment> = { 
        status,
        transaction_id: transaction_id || payment.transaction_id,
        notes: notes !== undefined ? notes : payment.notes
      };
      
      // Update the payment
      const updatedPayment = await storage.updatePartnerPayment(paymentId, updates);
      
      // Log the action
      await logMessage(
        LogLevel.INFO, 
        'Admin', 
        `Partner payment ${paymentId} processed: ${status}${transaction_id ? ` (Transaction ID: ${transaction_id})` : ''}`
      );
      
      res.json({
        success: true,
        message: `Payment ${status}`,
        payment: updatedPayment
      });
    } catch (error) {
      console.error("Error processing partner payment:", error);
      res.status(500).json({ error: "Failed to process partner payment" });
    }
  });
  
  // Process a referral when a user registers
  app.post('/api/register-with-referral', async (req, res) => {
    try {
      const { username, email, password, displayName, referral_code } = req.body;
      
      // Validate required fields
      if (!username || !email || !password) {
        return res.status(400).json({ error: "Missing required fields" });
      }
      
      // Check if referral code is valid
      if (referral_code) {
        const partner = await storage.getPartnerByReferralCode(referral_code);
        
        if (!partner) {
          return res.status(400).json({ error: "Invalid referral code" });
        }
        
        // Check if partner is active
        if (partner.status !== PartnerStatus.ACTIVE) {
          return res.status(400).json({ error: "This referral code is no longer active" });
        }
      }
      
      // Check if username or email already exists
      const existingUser = await storage.getUserByUsername(username) || await storage.getUserByEmail(email);
      
      if (existingUser) {
        return res.status(400).json({ error: "Username or email already exists" });
      }
      
      // Create the user
      const user = await storage.createUser({
        username,
        email,
        password,
        displayName: displayName || null,
        isAdmin: false,
      });
      
      // If referral code was provided, create the referral
      if (referral_code) {
        const partner = await storage.getPartnerByReferralCode(referral_code);
        
        if (partner) {
          // Create the referral
          await storage.createReferral({
            partner_id: partner.id,
            referred_user_id: user.id,
            referral_code: referral_code,
            status: ReferralStatus.ACTIVE
          });
          
          // Log the referral
          await logMessage(
            LogLevel.INFO, 
            'Partner', 
            `New referral: User ${user.id} referred by partner ${partner.company_name} (${referral_code})`
          );
        }
      }
      
      // Log in the user
      req.login(user, (err) => {
        if (err) {
          return res.status(500).json({ error: "Failed to login after registration" });
        }
        
        // Return success response
        res.status(201).json({ 
          success: true,
          message: "Registration successful",
          user: {
            id: user.id,
            username: user.username,
            email: user.email,
            displayName: user.displayName,
            isAdmin: user.isAdmin,
            coins: user.coins
          }
        });
      });
    } catch (error) {
      console.error("Error in registration with referral:", error);
      res.status(500).json({ error: "Failed to register user" });
    }
  });
  
  // Track a commission when a user makes a purchase
  app.post('/api/track-commission', isAuthenticated, async (req, res) => {
    try {
      const { transaction_id, amount } = req.body;
      
      if (!transaction_id || !amount || typeof amount !== 'number' || amount <= 0) {
        return res.status(400).json({ error: "Invalid transaction data" });
      }
      
      const user = req.user;
      
      // Check if the user was referred
      const referral = await storage.getReferralByUserId(user.id);
      
      if (!referral) {
        return res.status(404).json({ error: "No referral found for this user" });
      }
      
      // Get the partner
      const partner = await storage.getPartner(referral.partner_id);
      
      if (!partner) {
        return res.status(404).json({ error: "Partner not found" });
      }
      
      // Check if partner is active
      if (partner.status !== PartnerStatus.ACTIVE) {
        return res.status(400).json({ error: "Partner account is not active" });
      }
      
      // Calculate commission
      const commissionAmount = amount * partner.commission_rate;
      
      // Create the commission
      const commission = await storage.createPartnerCommission({
        partner_id: partner.id,
        referral_id: referral.id,
        transaction_id: parseInt(transaction_id),
        amount,
        commission_amount: commissionAmount,
        status: CommissionStatus.PENDING,
        payment_id: null
      });
      
      // Update the referral's total purchases
      await storage.updateReferral(referral.id, {
        total_purchases: referral.total_purchases + amount,
        first_purchase_date: referral.first_purchase_date || new Date()
      });
      
      // Log the commission
      await logMessage(
        LogLevel.INFO, 
        'Partner', 
        `New commission: ${partner.company_name} earned ${commissionAmount} from transaction ${transaction_id}`
      );
      
      res.status(201).json({
        success: true,
        message: "Commission tracked successfully",
        commission: {
          id: commission.id,
          partner_id: commission.partner_id,
          amount: commission.amount,
          commission_amount: commission.commission_amount,
          status: commission.status,
          created_at: commission.created_at
        }
      });
    } catch (error) {
      console.error("Error tracking commission:", error);
      res.status(500).json({ error: "Failed to track commission" });
    }
  });

  // Configuration APIs
  app.get('/api/config', async (req, res) => {
    try {
      const config = await storage.getConfig();
      res.json(config);
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error getting config: ${error}`);
      res.status(500).json({ error: 'Failed to get config' });
    }
  });
  
  // Update homepage AI configuration
  app.post('/api/config/homepage-ai', isAdmin, async (req, res) => {
    try {
      const homepageAIConfig = req.body;
      const config = await storage.getConfig();
      
      // Update configuration with the homepage AI settings
      const updatedConfig = await storage.updateConfig({
        ...config,
        systemPrompt: homepageAIConfig.systemPrompt,
        elevenLabsVoiceId: homepageAIConfig.elevenLabsVoiceId,
        openaiModel: homepageAIConfig.openaiModel,
        temperature: homepageAIConfig.temperature,
        maxTokens: homepageAIConfig.maxTokens,
        continuousConversation: homepageAIConfig.continuousConversation,
        showTranscript: homepageAIConfig.showTranscript,
        greetingMessage: homepageAIConfig.greetingMessage,
      });
      
      // Log the configuration update
      await logMessage(
        LogLevel.INFO, 
        'admin', 
        `Homepage AI configuration updated by ${(req as any).user ? (req as any).user.email || 'admin' : 'unknown user'}`
      );
      
      res.json(updatedConfig);
    } catch (error) {
      console.error('Failed to update homepage AI configuration:', error);
      res.status(500).json({ error: 'Failed to update homepage AI configuration' });
    }
  });
  
  app.post('/api/config', async (req, res) => {
    try {
      const config = req.body;
      await storage.updateConfig(config);
      logMessage(LogLevel.INFO, 'API', 'Configuration updated');
      res.json({ success: true });
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error saving config: ${error}`);
      res.status(500).json({ error: 'Failed to save config' });
    }
  });
  
  // Homepage AI configuration endpoint
  app.post('/api/homepage-ai-config', isAuthenticated, async (req, res) => {
    try {
      // Check if user is admin
      if (!(req as any).user?.isAdmin) {
        return res.status(403).json({ error: 'Not authorized - Admin access required' });
      }
      
      const homepageAIConfig = req.body;
      
      // Get current config
      const config = await storage.getConfig();
      
      // Update the config with homepage AI specific settings
      const updatedConfig = await storage.updateConfig({
        ...config,
        systemPrompt: homepageAIConfig.systemPrompt,
        elevenLabsVoiceId: homepageAIConfig.elevenLabsVoiceId,
        openaiModel: homepageAIConfig.openaiModel,
        temperature: homepageAIConfig.temperature,
        maxTokens: homepageAIConfig.maxTokens,
        continuousConversation: homepageAIConfig.continuousConversation,
        showTranscript: homepageAIConfig.showTranscript,
        greetingMessage: homepageAIConfig.greetingMessage,
      });
      
      // Log the configuration update
      await logMessage(
        LogLevel.INFO, 
        'admin', 
        `Homepage AI configuration updated by ${(req as any).user ? (req as any).user.email || 'admin' : 'unknown user'}`
      );
      
      res.json(updatedConfig);
    } catch (error) {
      console.error('Failed to update homepage AI configuration:', error);
      res.status(500).json({ error: 'Failed to update homepage AI configuration' });
    }
  });
  
  // Agent endpoints
  app.get('/api/agents', async (req, res) => {
    try {
      const agents = await storage.getAgents();
      res.json(agents);
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error fetching agents: ${error}`);
      res.status(500).json({ error: 'Failed to fetch agents' });
    }
  });
  
  app.get('/api/agents/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const agent = await storage.getAgent(id);
      
      if (!agent) {
        return res.status(404).json({ error: 'Agent not found' });
      }
      
      res.json(agent);
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error fetching agent: ${error}`);
      res.status(500).json({ error: 'Failed to fetch agent' });
    }
  });
  
  app.post('/api/agents', async (req, res) => {
    try {
      const agentData = req.body;
      const newAgent = await storage.createAgent(agentData);
      
      logMessage(LogLevel.INFO, 'API', `Created new agent: ${newAgent.name}`);
      res.status(201).json(newAgent);
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error creating agent: ${error}`);
      res.status(500).json({ error: 'Failed to create agent' });
    }
  });
  
  app.patch('/api/agents/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const agentUpdate = req.body;
      
      const updatedAgent = await storage.updateAgent(id, agentUpdate);
      
      if (!updatedAgent) {
        return res.status(404).json({ error: 'Agent not found' });
      }
      
      logMessage(LogLevel.INFO, 'API', `Updated agent: ${updatedAgent.name}`);
      res.json(updatedAgent);
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error updating agent: ${error}`);
      res.status(500).json({ error: 'Failed to update agent' });
    }
  });
  
  app.delete('/api/agents/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteAgent(id);
      
      if (!deleted) {
        return res.status(400).json({ error: 'Cannot delete the only agent' });
      }
      
      logMessage(LogLevel.INFO, 'API', `Deleted agent with ID: ${id}`);
      res.status(204).send();
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error deleting agent: ${error}`);
      res.status(500).json({ error: 'Failed to delete agent' });
    }
  });
  
  // ElevenLabs APIs
  // Create directory for audio files if it doesn't exist
  // Create directory for audio files if it doesn't exist
  try {
    if (!fs.existsSync('/tmp')) {
      fs.mkdirSync('/tmp');
    }
  } catch (error) {
    console.error('Error creating /tmp directory:', error);
  }

  // API endpoint to serve generated audio files
  app.get('/api/audio/:filename', (req, res) => {
    try {
      const { filename } = req.params;
      const filePath = `/tmp/${filename}`;
      
      console.log(`Serving audio file: ${filePath}`);
      
      // Verify the file exists
      if (!fs.existsSync(filePath)) {
        console.error(`Audio file not found: ${filePath}`);
        return res.status(404).json({ error: 'Audio file not found' });
      }
      
      // Get file stats to include file size in headers
      const stats = fs.statSync(filePath);
      
      // Check if this is a download request (via query param)
      const isDownload = req.query.download === 'true';
      
      if (isDownload) {
        console.log('Serving file as attachment for download');
        // Set headers for file download
        res.setHeader('Content-Type', 'audio/mpeg');
        res.setHeader('Content-Length', stats.size);
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
        res.setHeader('X-Content-Type-Options', 'nosniff');
      } else {
        // Set headers for normal streaming
        res.setHeader('Content-Type', 'audio/mpeg');
        res.setHeader('Content-Length', stats.size);
        res.setHeader('Accept-Ranges', 'bytes');
      }
      
      // Always add these headers
      res.setHeader('Access-Control-Expose-Headers', 'Content-Disposition, Content-Length');
      res.setHeader('Cache-Control', 'no-cache');
      
      // Stream the file to the client
      const fileStream = fs.createReadStream(filePath);
      fileStream.pipe(res);
      
      fileStream.on('error', (error: Error) => {
        console.error('Error streaming audio file:', error);
        if (!res.headersSent) {
          res.status(500).json({ error: 'Error streaming audio file' });
        } else {
          res.end();
        }
      });
    } catch (error) {
      console.error('Error serving audio file:', error);
      res.status(500).json({ error: 'Failed to serve audio file' });
    }
  });

  app.get('/api/elevenlabs/voices', async (req, res) => {
    console.log('Received request for /api/elevenlabs/voices');
    try {
      console.log('Calling getElevenLabsVoices function');
      const voices = await getElevenLabsVoices();
      console.log(`Successfully retrieved ${voices.length} ElevenLabs voices`);
      res.json(voices);
    } catch (error) {
      console.error('Error in /api/elevenlabs/voices endpoint:', error);
      logMessage(LogLevel.ERROR, 'API', `Error getting ElevenLabs voices: ${error}`);
      res.status(500).json({ error: 'Failed to get ElevenLabs voices' });
    }
  });

  app.post('/api/elevenlabs/synthesize', async (req, res) => {
    try {
      const { text, voiceId, optimize_streaming_latency, speed, stability, similarity, download } = req.body;
      
      if (!text) {
        return res.status(400).json({ error: 'Text is required' });
      }
      
      console.log(`Synthesizing voice with ElevenLabs: "${text.substring(0, 50)}..." using voiceId: ${voiceId}`);

      // Create a unique file ID for this audio generation
      const fileId = `voice_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
      // Format text for filename - truncate and remove invalid characters
      const cleanText = text
        ? text.substring(0, 40).replace(/[^\w\s-]/g, '').trim().replace(/\s+/g, '-')
        : 'voiceover';
      const fileName = download ? `${cleanText}-${fileId.substring(0, 8)}.mp3` : `${fileId}.mp3`;
      const filePath = `/tmp/${fileName}`;
      
      // Generate the audio file URL based on our server host
      let audioUrl;
      // Use the same protocol and host that the request came from
      const protocol = req.protocol;
      const host = req.get('host') || 'localhost:5000';
      audioUrl = `${protocol}://${host}/api/audio/${fileName}`;
      
      // Create stream to file
      const fileWriteStream = fs.createWriteStream(filePath);
      
      try {
        // Use the stream-optimized version of the TTS function
        const audioStream = await getTtsStream(text, {
          voiceId, 
          optimize_streaming_latency: optimize_streaming_latency || 4, // Maximum optimization by default
          voice_speed: speed || 1.0,
          stability: stability || 0.5,
          similarity_boost: similarity || 0.75,
          output_format: "mp3_44100_128", // Optimized for web playback
          timeout: 10000 // 10 second timeout for faster response
        });
        
        // Save the audio stream to file
        audioStream.pipe(fileWriteStream);
        
        // Handle completion and errors
        audioStream.on('end', () => {
          console.log(`Audio file saved successfully to ${filePath}`);
          res.json({ 
            audioUrl: audioUrl,
            message: 'Voice generated successfully',
            fileName: fileName,
            text: text 
          });
        });
        
        // Handle stream errors
        audioStream.on('error', (error: Error) => {
          console.error('Error streaming audio to file:', error);
          fileWriteStream.end();
          if (fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
          }
          res.status(500).json({ error: 'Audio generation error: ' + error.message });
        });
        
        // Return early - the stream completion will handle the response
        return;
      } catch (error) {
        // Log the error and continue with fallback method
        console.error('Optimized audio streaming failed, falling back to traditional method:', error);
        fileWriteStream.end();
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
        }
      }
      
      // Fallback method if streaming fails
      const config = await storage.getConfig();
      
      // Use the API key from environment variable if not in config
      const apiKey = config.elevenLabsApiKey || process.env.ELEVENLABS_API_KEY;
      
      if (!apiKey) {
        return res.status(400).json({ error: 'ElevenLabs API key is required' });
      }
      
      // Get the voice ID (use specified voiceId, configured voice, or default to Jessica voice)
      const selectedVoiceId = voiceId || config.elevenLabsVoiceId || 'jsCqWAovK2LkecY7zXl4'; // Jessica voice ID
      
      // Get the model ID or use a default
      const modelId = config.modelId || 'eleven_monolingual_v1';
      
      // Request audio file from ElevenLabs - with optimization parameters
      const response = await axios({
        method: 'post',
        url: `https://api.elevenlabs.io/v1/text-to-speech/${selectedVoiceId}`,
        headers: {
          'Accept': 'audio/mpeg',
          'xi-api-key': apiKey,
          'Content-Type': 'application/json'
        },
        data: {
          text,
          model_id: modelId,
          voice_settings: {
            stability: stability || config.stability || 0.5,
            similarity_boost: similarity || config.similarity || 0.75,
            speed: speed || 1.0
          }
        },
        responseType: 'arraybuffer'
      });
      
      // Track API usage
      await storage.incrementApiMetric('elevenlabs', 0, text.length);
      
      // Return the audio file
      res.setHeader('Content-Type', 'audio/mpeg');
      res.send(Buffer.from(response.data));
    } catch (error) {
      console.error('Error synthesizing speech:', error);
      res.status(500).json({ error: 'Failed to synthesize speech' });
    }
});

app.get('/api/elevenlabs/voices/play/:voiceId', async (req, res) => {
    try {
      const { voiceId } = req.params;
      if (!voiceId) {
        return res.status(400).json({ error: 'Voice ID is required' });
      }
      
      const config = await storage.getConfig();
      
      // Use the API key from environment variable if not in config
      const apiKey = config.elevenLabsApiKey || process.env.ELEVENLABS_API_KEY;
      
      if (!apiKey) {
        return res.status(400).json({ error: 'ElevenLabs API key is required' });
      }
      
      // Use a specific sample text as requested for voice preview
      // This text clearly identifies the purpose without creating agents
      const sampleText = "Hi, I'm your AI assistant. Here's how I sound.";
      
      try {
        // First try to use the streaming API, which is often more reliable
        const audioStream = await getTtsStream(sampleText, {
          voiceId, 
          optimize_streaming_latency: 4, // Maximum optimization 
          output_format: "mp3_44100_128", // Optimized for web playback
          timeout: 10000 // 10 second timeout for faster response
        });
        
        // Stream directly to client with appropriate headers
        res.setHeader('Content-Type', 'audio/mpeg');
        res.setHeader('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours
        
        // Pipe the audio stream directly to response
        audioStream.pipe(res);
        
        // Handle stream errors
        audioStream.on('error', (error: Error) => {
          console.error('Error streaming voice sample:', error);
          if (!res.headersSent) {
            res.status(500).json({ error: 'Voice sample streaming error' });
          } else {
            res.end();
          }
        });
        
        // Track API usage
        await storage.incrementApiMetric('elevenlabs', 0, sampleText.length);
        
        // Return early - the stream will handle the response
        return;
        
      } catch (streamError) {
        // Log streaming error but continue with fallback method
        console.log('Voice sample streaming failed, using traditional method:', streamError);
      }
      
      // Get the model ID or use a default
      const modelId = config.modelId || 'eleven_monolingual_v1';
      
      // Fallback: Request audio file from ElevenLabs using traditional method
      const response = await axios({
        method: 'post',
        url: `https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`,
        headers: {
          'Accept': 'audio/mpeg',
          'xi-api-key': apiKey,
          'Content-Type': 'application/json'
        },
        data: {
          text: sampleText,
          model_id: modelId,
          voice_settings: {
            stability: config.stability || 0.5,
            similarity_boost: config.similarity || 0.75,
          }
        },
        responseType: 'arraybuffer'
      });
      
      // Track API usage if we didn't track it above
      await storage.incrementApiMetric('elevenlabs', 0, sampleText.length);
      
      // Return the audio file with caching headers
      res.setHeader('Content-Type', 'audio/mpeg');
      res.setHeader('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours
      res.send(Buffer.from(response.data));
    } catch (error) {
      console.error('Error playing voice sample:', error);
      logMessage(LogLevel.ERROR, 'API', `Error playing voice sample: ${error}`);
      res.status(500).json({ error: 'Failed to play voice sample' });
    }
  });
  
  app.get('/api/elevenlabs/models', async (req, res) => {
    try {
      const models = await getElevenLabsModels();
      res.json(models);
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error getting ElevenLabs models: ${error}`);
      res.status(500).json({ error: 'Failed to get ElevenLabs models' });
    }
  });

  // Adding compatibility redirect for any client still calling the old Play.ht API
  app.get('/api/playht/voices', async (req, res) => {
    console.log('Received deprecated request for /api/playht/voices - redirecting to ElevenLabs API');
    try {
      // Redirect to the ElevenLabs voices API
      const voices = await getElevenLabsVoices();
      console.log(`Redirected Play.ht request to ElevenLabs and retrieved ${voices.length} voices`);
      res.json(voices);
    } catch (error) {
      console.error('Error in Play.ht compatibility layer:', error);
      logMessage(LogLevel.ERROR, 'API', `Error getting ElevenLabs voices via Play.ht compatibility: ${error}`);
      res.status(500).json({ error: 'Failed to get voices' });
    }
  });

  app.post('/api/playht/synthesize', async (req, res) => {
    console.log('Received deprecated request for /api/playht/synthesize - redirecting to ElevenLabs API');
    try {
      const { text, voiceId, speed, pitch } = req.body;
      
      if (!text || text.trim() === '') {
        return res.status(400).json({ error: 'Text is required' });
      }

      if (!voiceId) {
        return res.status(400).json({ error: 'Voice ID is required' });
      }

      // Log the request
      await logMessage(LogLevel.INFO, 'API', `Play.ht synthesis request redirected to ElevenLabs: ${text.substring(0, 50)}... with voice ${voiceId}`);
      
      // Map pitch to ElevenLabs parameters - use similarity as equivalent
      const similarity = (pitch && pitch > 1) ? 0.8 : 0.6;
      
      try {
        // Use the ElevenLabs streaming method instead
        const audioStream = await getTtsStream(text, {
          voiceId, 
          optimize_streaming_latency: 4,
          voice_speed: speed || 1.0,
          stability: 0.5,
          similarity_boost: similarity,
          output_format: "mp3_44100_128"
        });
        
        // Set appropriate headers
        res.setHeader('Content-Type', 'audio/mpeg');
        
        // Stream the audio directly to the response
        audioStream.pipe(res);
        
        // Handle errors
        audioStream.on('error', (error: Error) => {
          console.error('Error streaming audio in compatibility layer:', error);
          if (!res.headersSent) {
            res.status(500).json({ error: 'Audio streaming error' });
          } else {
            res.end();
          }
        });
      } catch (streamError) {
        console.error('Error in Play.ht compatibility streaming:', streamError);
        res.status(500).json({ error: 'Failed to generate audio' });
      }
    } catch (error) {
      console.error('Error in Play.ht compatibility layer:', error);
      logMessage(LogLevel.ERROR, 'API', `Error synthesizing speech with compatibility layer: ${error}`);
      res.status(500).json({ error: 'Failed to synthesize speech' });
    }
  });
  
  // Server control APIs
  app.post('/api/server/restart', (req, res) => {
    logMessage(LogLevel.INFO, 'API', 'Server restart requested');
    res.json({ success: true, message: 'Server restart initiated' });
    
    // In a real app, we'd implement a proper restart
    // For this demo, we'll just simulate it
    broadcastToAll({
      type: 'server_status',
      payload: {
        online: false,
        message: 'Server Restarting...'
      }
    });
    
    setTimeout(() => {
      broadcastToAll({
        type: 'server_status',
        payload: {
          online: true,
          message: 'Server Online'
        }
      });
    }, 3000);
  });
  
  // Twilio Voice Webhook
  app.post('/api/twilio/voice', async (req, res) => {
    try {
      const twilioResponse = await handleTwilioWebhook(req.body, req);
      res.set('Content-Type', 'text/xml');
      res.send(twilioResponse);
    } catch (error) {
      logMessage(LogLevel.ERROR, 'Phone Number', `Error handling voice webhook: ${error}`);
      res.status(500).send('Error processing voice webhook');
    }
  });
  
  // Optimized Chat API endpoint for the floating chat bubble
  app.post('/api/chat', async (req, res) => {
    try {
      console.log('Chat API received request body:', JSON.stringify(req.body));
      const { message, conversation } = req.body;
      
      if (!message || typeof message !== 'string' || message.trim() === '') {
        return res.status(400).json({ error: 'Message is required' });
      }
      
      // Set the OpenAI API key directly from the chat endpoint
      process.env.OPENAI_API_KEY = process.env.OPENAI_API_KEY || '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';
      
      // Trim the message for consistency
      const trimmedMessage = message.trim();
      
      // Log the incoming message asynchronously (don't await)
      logMessage(LogLevel.INFO, 'API', `Chat message received: "${trimmedMessage.substring(0, 50)}${trimmedMessage.length > 50 ? '...' : ''}"`)
        .catch(err => console.error('Error logging message:', err));
      
      // Track metrics asynchronously (don't await)
      storage.incrementApiMetric('openai', 0, 0, undefined, undefined, '/api/chat')
        .catch(err => console.error('Error incrementing API metric:', err));
      
      // Performance optimization: Process the response with minimal latency
      const aiResponse = await chatWithAssistant(trimmedMessage, conversation || [], {
        max_tokens: 150, // Limit token count for faster response
        temperature: 0.7, // Lower temperature for more deterministic responses
      });
      
      // Return the response immediately
      res.json({ 
        response: aiResponse,
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      console.error('Error processing chat message:', error);
      
      // Log error asynchronously (don't await)
      logMessage(LogLevel.ERROR, 'API', `Chat error: ${error?.message || 'Unknown error'}`)
        .catch(err => console.error('Error logging error message:', err));
      
      // Provide a fast fallback response in case of error
      if (error?.status === 401) {
        return res.status(401).json({ 
          error: 'OpenAI API key authentication error', 
          message: 'Your OpenAI API key may be invalid or may not have the necessary permissions.' 
        });
      }
      
      if (error?.status === 429) {
        return res.status(429).json({ 
          error: 'OpenAI API rate limit exceeded', 
          message: 'Please try again in a few moments.' 
        });
      }
      
      res.status(500).json({ 
        error: 'Failed to process chat message',
        message: error?.message || 'Unknown error occurred' 
      });
    }
  });

  // Twilio Incoming Audio webhook
  app.post('/api/twilio/audio', async (req, res) => {
    try {
      const { CallSid, SpeechResult } = req.body;
      
      if (!CallSid || !SpeechResult) {
        return res.status(400).json({ error: 'Missing required parameters' });
      }
      
      logMessage(LogLevel.INFO, 'Phone Number', `Received speech: ${SpeechResult} from call ${CallSid}`);
      
      // Get or initialize conversation context
      if (!conversationContexts.has(CallSid)) {
        conversationContexts.set(CallSid, []);
      }
      const context = conversationContexts.get(CallSid) || [];
      
      // Set the OpenAI API key directly
      process.env.OPENAI_API_KEY = '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';
      
      // Process with OpenAI
      const openaiResponse = await getOpenAIResponse(SpeechResult, context);
      
      // Update conversation context
      context.push({ role: 'user', content: SpeechResult });
      context.push({ role: 'assistant', content: openaiResponse });
      conversationContexts.set(CallSid, context);
      
      // Get TTS stream from ElevenLabs
      const audioStream = await getTtsStream(openaiResponse);
      
      // Get webhook base URL for Twilio to correctly call our endpoint
      let webhookBaseUrl;
      if (process.env.REPL_SLUG && process.env.REPL_OWNER) {
        webhookBaseUrl = `https://${process.env.REPL_SLUG}-${process.env.REPL_OWNER}.repl.co`;
      } else {
        const host = req.get('host') || 'localhost:5000';
        webhookBaseUrl = `https://${host.replace('localhost:5000', 'workspace-emilghelmeci.repl.co')}`;
      }
      
      // Return TwiML response with the AI-generated message
      const twiml = `
      <?xml version="1.0" encoding="UTF-8"?>
      <Response>
        <Say>${openaiResponse}</Say>
        <Gather input="speech" action="${webhookBaseUrl}/api/twilio/audio" method="POST" speechTimeout="auto" language="en-US">
          <Say>Is there anything else you'd like to know?</Say>
        </Gather>
      </Response>
      `;
      
      res.set('Content-Type', 'text/xml');
      res.send(twiml);
      
      // Broadcast update to all clients
      broadcastToAll({
        type: 'conversation_update',
        callSid: CallSid,
        userMessage: SpeechResult,
        aiResponse: openaiResponse
      });
    } catch (error) {
      logMessage(LogLevel.ERROR, 'Phone Number', `Error processing audio: ${error}`);
      
      // Even on error, return valid TwiML to prevent the call from hanging up
      const twiml = `
      <?xml version="1.0" encoding="UTF-8"?>
      <Response>
        <Say>I'm sorry, I encountered a problem processing your request. Let me try again.</Say>
        <Gather input="speech" action="${req.protocol}://${req.get('host')}/api/twilio/audio" method="POST" speechTimeout="auto" language="en-US">
          <Say>Could you please repeat your question?</Say>
        </Gather>
      </Response>
      `;
      
      res.set('Content-Type', 'text/xml');
      res.send(twiml);
    }
  });
  
  // Twilio Recording Webhook
  app.post('/api/twilio/recording', async (req, res) => {
    try {
      const recordingResponse = await handleRecordingWebhook(req.body);
      res.set('Content-Type', 'text/xml');
      res.send(recordingResponse);
      
      // Broadcast recording update
      broadcastToAll({
        type: 'recording_update',
        callSid: req.body.CallSid,
        recordingUrl: req.body.RecordingUrl
      });
    } catch (error) {
      logMessage(LogLevel.ERROR, 'Phone Number', `Error handling recording webhook: ${error}`);
      
      // Return empty TwiML response even on error
      const twiml = `<?xml version="1.0" encoding="UTF-8"?><Response></Response>`;
      res.set('Content-Type', 'text/xml');
      res.send(twiml);
    }
  });
  
  // Twilio Recording Status Webhook
  app.post('/api/twilio/recording-status', async (req, res) => {
    try {
      const statusResponse = await handleRecordingStatusWebhook(req.body);
      res.set('Content-Type', 'text/xml');
      res.send(statusResponse);
    } catch (error) {
      logMessage(LogLevel.ERROR, 'Phone Number', `Error handling recording status webhook: ${error}`);
      
      // Return empty TwiML response even on error
      const twiml = `<?xml version="1.0" encoding="UTF-8"?><Response></Response>`;
      res.set('Content-Type', 'text/xml');
      res.send(twiml);
    }
  });
  
  // Get recordings for a call
  app.get('/api/calls/:callSid/recording', async (req, res) => {
    try {
      const { callSid } = req.params;
      const call = await storage.getCallBySid(callSid);
      
      if (!call) {
        return res.status(404).json({ error: 'Call not found' });
      }
      
      res.json({
        recordingUrl: call.recordingUrl,
        recordingSid: call.recordingSid,
        transcript: call.transcript
      });
    } catch (error) {
      logMessage(LogLevel.ERROR, 'API', `Error fetching call recording: ${error}`);
      res.status(500).json({ error: 'Failed to fetch call recording' });
    }
  });

  // Add event listeners for process termination to clean up resources
  process.on('SIGTERM', () => {
    console.log('SIGTERM received, shutting down gracefully');
    
    // Clear the member counter timer if it exists
    if (memberCounterTimer) {
      clearTimeout(memberCounterTimer);
      console.log('Member counter timer cleared');
    }
    
    httpServer.close(() => {
      console.log('Server closed');
      process.exit(0);
    });
  });
  
  process.on('SIGINT', () => {
    console.log('SIGINT received, shutting down gracefully');
    
    // Clear the member counter timer if it exists
    if (memberCounterTimer) {
      clearTimeout(memberCounterTimer);
      console.log('Member counter timer cleared');
    }
    
    httpServer.close(() => {
      console.log('Server closed');
      process.exit(0);
    });
  });
  
  // Saved Referral Links API Endpoints
  app.get('/api/partner/saved-referral-links', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      
      // Get all saved referral links for this partner
      const savedLinks = await storage.getSavedReferralLinks(partner.id);
      
      res.json(savedLinks);
    } catch (error) {
      console.error('Error getting saved referral links:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  });

  app.post('/api/partner/saved-referral-links', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      
      // Extract data from request
      const { name, base_url, full_url, campaign, utm_source, utm_medium, utm_campaign, utm_content, utm_term } = req.body;
      
      // Create new saved referral link
      const savedLink = await storage.createSavedReferralLink({
        partner_id: partner.id,
        name,
        base_url,
        full_url,
        campaign,
        utm_source,
        utm_medium,
        utm_campaign,
        utm_content,
        utm_term,
        click_count: 0 
      });
      
      res.status(201).json(savedLink);
    } catch (error) {
      console.error('Error creating saved referral link:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  });

  app.get('/api/partner/saved-referral-links/:id', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      const linkId = parseInt(req.params.id);
      
      if (isNaN(linkId)) {
        return res.status(400).json({ error: 'Invalid link ID' });
      }
      
      // Get the saved referral link
      const savedLink = await storage.getSavedReferralLink(linkId);
      
      if (!savedLink) {
        return res.status(404).json({ error: 'Saved referral link not found' });
      }
      
      // Check if the link belongs to this partner
      if (savedLink.partner_id !== partner.id) {
        return res.status(403).json({ error: 'Access forbidden - This link belongs to another partner' });
      }
      
      res.json(savedLink);
    } catch (error) {
      console.error('Error getting saved referral link:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  });

  app.patch('/api/partner/saved-referral-links/:id', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      const linkId = parseInt(req.params.id);
      
      if (isNaN(linkId)) {
        return res.status(400).json({ error: 'Invalid link ID' });
      }
      
      // Get the existing saved link
      const existingLink = await storage.getSavedReferralLink(linkId);
      
      // Check if the link exists and belongs to this partner
      if (!existingLink) {
        return res.status(404).json({ error: 'Saved referral link not found' });
      }
      
      if (existingLink.partner_id !== partner.id) {
        return res.status(403).json({ error: 'Access forbidden - This link belongs to another partner' });
      }
      
      // Extract fields to update
      const { name, base_url, full_url, campaign, utm_source, utm_medium, utm_campaign, utm_content, utm_term } = req.body;
      
      // Update the saved referral link
      const updatedLink = await storage.updateSavedReferralLink(linkId, {
        name: name !== undefined ? name : undefined,
        base_url: base_url !== undefined ? base_url : undefined,
        full_url: full_url !== undefined ? full_url : undefined,
        campaign: campaign !== undefined ? campaign : undefined,
        utm_source: utm_source !== undefined ? utm_source : undefined,
        utm_medium: utm_medium !== undefined ? utm_medium : undefined,
        utm_campaign: utm_campaign !== undefined ? utm_campaign : undefined,
        utm_content: utm_content !== undefined ? utm_content : undefined,
        utm_term: utm_term !== undefined ? utm_term : undefined
      });
      
      res.json(updatedLink);
    } catch (error) {
      console.error('Error updating saved referral link:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  });

  app.delete('/api/partner/saved-referral-links/:id', isPartner, async (req, res) => {
    try {
      const partner = (req as any).partner;
      const linkId = parseInt(req.params.id);
      
      if (isNaN(linkId)) {
        return res.status(400).json({ error: 'Invalid link ID' });
      }
      
      // Get the existing saved link
      const existingLink = await storage.getSavedReferralLink(linkId);
      
      // Check if the link exists and belongs to this partner
      if (!existingLink) {
        return res.status(404).json({ error: 'Saved referral link not found' });
      }
      
      if (existingLink.partner_id !== partner.id) {
        return res.status(403).json({ error: 'Access forbidden - This link belongs to another partner' });
      }
      
      // Delete the saved referral link
      const deleted = await storage.deleteSavedReferralLink(linkId);
      
      if (deleted) {
        res.status(204).end();
      } else {
        res.status(500).json({ error: 'Failed to delete saved referral link' });
      }
    } catch (error) {
      console.error('Error deleting saved referral link:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  });

  // Endpoint to track clicks on saved referral links
  app.post('/api/partner/saved-referral-links/:id/click', async (req, res) => {
    try {
      const linkId = parseInt(req.params.id);
      
      if (isNaN(linkId)) {
        return res.status(400).json({ error: 'Invalid link ID' });
      }
      
      // Increment the click count for this link
      const updated = await storage.incrementSavedReferralLinkClickCount(linkId);
      
      if (updated) {
        res.status(200).json({ success: true });
      } else {
        res.status(404).json({ error: 'Saved referral link not found' });
      }
    } catch (error) {
      console.error('Error tracking click on saved referral link:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  });

  // AI Clip Studio - Generate clips from long videos (accessible without login)
  app.post('/api/clip', uploadSingleClipVideo, async (req, res) => {
    try {
      console.log("=== API /api/clip endpoint hit ===");
      console.log("Request body:", req.body);
      console.log("Request file:", req.file);
      
      // Check if we received a file
      if (!req.file) {
        console.error("No file received in upload");
        return res.status(400).json({ error: "No video file uploaded" });
      }
      
      console.log(`Received file: ${req.file.originalname}, size: ${req.file.size}, mimetype: ${req.file.mimetype}`);
      console.log("Request headers:", JSON.stringify(req.headers));
      console.log("Request body:", req.body);
      
      // Check if video file was uploaded
      if (!req.file) {
        console.error("ERROR: No video file uploaded in request");
        return res.status(400).json({ error: 'No video file uploaded' });
      } else {
        console.log("File uploaded successfully:", req.file.originalname);
        console.log("File details:", {
          path: req.file.path,
          size: req.file.size,
          mimetype: req.file.mimetype
        });
      }

      const { keywords, captionStyle } = req.body;
      console.log("Processing clip generation request with keywords:", keywords || 'none');
      console.log("Caption style selected:", captionStyle || 'default');
      
      // The cost for clip generation is 15 coins per video for logged-in users
      const COIN_COST = 15;
      let userId = null;
      let userCoins = 0;
      
      // Check if the user is authenticated to track coin costs
      try {
        if (req.isAuthenticated && req.isAuthenticated() && req.user) {
          userId = req.user.id;
          
          // Get the user's coin balance
          userCoins = await storage.getUserCoins(userId);
          console.log(`User ${userId} has ${userCoins} coins`);
          
          // Check if the user has enough coins
          if (userCoins < COIN_COST) {
            return res.status(403).json({ 
              error: 'Insufficient coins', 
              required: COIN_COST, 
              balance: userCoins
            });
          }
          
          // Deduct coins from the user's balance
          await storage.addUserCoins(
            userId,
            -COIN_COST,
            TransactionType.USAGE,
            'AI Clip Studio: Generate video clips'
          );
          
          console.log(`Deducted ${COIN_COST} coins from user ${userId}`);
        } else {
          console.log("Anonymous user accessing AI Clip Studio - no authentication required");
        }
      } catch (authError) {
        console.log("Error checking authentication, proceeding as anonymous user:", authError);
      }
      
      try {
        // Call the Klap API to generate clips
        const videoPath = req.file.path;
        
        // Log the upload path and keywords for debugging
        console.log(`Processing clip generation for video at path: ${videoPath}`);
        console.log(`Using keywords: ${keywords || 'none'}`);
        
        // Check if we have a valid Spike API key and use the real API if available
        let results;
        const apiKey = process.env.SPIKE_API_KEY;
        
        // Enhanced logging for API key detection
        if (apiKey) {
          console.log(`Using real Spike Studio API for clip generation with API key: ${apiKey.substring(0, 4)}...${apiKey.substring(apiKey.length - 4)}`);
          console.log("API key type:", typeof apiKey, "Length:", apiKey.length);
          
          try {
            // Force real API usage even with placeholder key for testing
            results = await generateClips(videoPath, keywords, captionStyle);
            
            // If there was an error with the Spike Studio API, fallback to mock implementation
            if (!results.success) {
              console.error("Error with Spike Studio API, falling back to mock implementation:", results.error);
              results = await Promise.resolve(mockGenerateClips(videoPath, keywords, captionStyle));
            }
          } catch (err) {
            console.error("Exception with Spike Studio API, falling back to mock implementation:", err);
            results = await Promise.resolve(mockGenerateClips(videoPath, keywords, captionStyle));
          }
        } else {
          console.log("No Spike API key found, using mock clip generation");
          // Using enhanced mock function - wrap in Promise to ensure proper async behavior
          results = await Promise.resolve(mockGenerateClips(videoPath, keywords, captionStyle));
        }
        
        console.log(`Successfully generated ${results.clips?.length || 0} clips from ${videoPath}`);
        
        // Check if clip generation was successful
        if (!results.success) {
          // If user was charged coins, refund them since the operation failed
          if (userId) {
            await storage.addUserCoins(
              userId,
              COIN_COST,
              TransactionType.REFUND,
              'Refund: AI Clip Studio failed to generate clips'
            );
            console.log(`Refunded ${COIN_COST} coins to user ${userId} due to failed clip generation`);
          }
          
          return res.status(500).json({
            error: results.error || 'Failed to generate clips',
            details: results.details || 'Unknown error occurred during clip generation'
          });
        }
        
        // Return the clips to the client
        console.log("Sending successful response with clips:", results);
        
        // Return the full results object directly with additional coin information
        return res.status(200).json({
          ...results,
          coinCost: userId ? COIN_COST : 0,
          newBalance: userId ? (userCoins - COIN_COST) : 0
        });
      } catch (error: any) {
        // If user was charged coins, refund them since an error occurred
        if (userId) {
          await storage.addUserCoins(
            userId,
            COIN_COST,
            TransactionType.REFUND,
            'Refund: AI Clip Studio error'
          );
          console.log(`Refunded ${COIN_COST} coins to user ${userId} due to error during clip generation`);
        }
        
        console.error("Error during clip generation:", error);
        return res.status(500).json({ 
          error: 'Failed to generate clips',
          details: error.message || 'Unknown error occurred'
        });
      }
    } catch (error: any) {
      console.error("Error processing clip generation request:", error);
      res.status(500).json({ 
        error: 'Server error during clip generation',
        details: error.message || 'Unknown server error'
      });
    }
  });
  
  // AI Clip Studio - Download clip in vertical reel format
  app.get('/api/clip/download/:id', async (req, res) => {
    try {
      console.log("=== API /api/clip/download endpoint hit ===");
      const clipId = req.params.id;
      console.log(`Clip download requested for ID: ${clipId}`);
      
      // Import the clip extractor
      const { extractClip } = require('./lib/video-processor/clip-extractor');
      
      // Get the processed clips directory
      const processedClipsDir = path.join(process.cwd(), 'public', 'processed-clips');
      
      // Ensure the directory exists
      if (!fs.existsSync(processedClipsDir)) {
        fs.mkdirSync(processedClipsDir, { recursive: true });
      }
      
      // First attempt: try to find the exact file if clipId is a filename
      let clipPath = path.join(processedClipsDir, clipId);
      
      // If the path doesn't have an extension, assume it's .mp4
      if (!path.extname(clipPath)) {
        clipPath += '.mp4';
      }
      
      console.log(`Looking for clip at path: ${clipPath}`);
      
      if (fs.existsSync(clipPath)) {
        console.log(`Found processed clip: ${clipPath}`);
        return res.download(clipPath);
      }
      
      // Second attempt: search for files matching the pattern
      console.log("Exact file not found, searching for matching files...");
      const files = fs.readdirSync(processedClipsDir);
      
      // Find files containing clipId or other clip identifiers
      const matchingFiles = files.filter(file => 
        file.includes(clipId) || 
        file.includes(`clip_${clipId}`) || 
        file.includes(`reel_clip_${clipId}`)
      );
      
      if (matchingFiles.length > 0) {
        const matchedFile = matchingFiles[0]; // Use the first match
        console.log(`Found matching clip by pattern: ${matchedFile}`);
        return res.download(path.join(processedClipsDir, matchedFile));
      }
      
      // Third attempt: Use query params to extract a clip on-the-fly if no processed clip is found
      let sourceVideo = req.query.source as string;
      const startTime = Number(req.query.start || 0);
      const endTime = Number(req.query.end || (startTime + 30)); // Default to 30 seconds after start
      const format = req.query.format as string || 'vertical';
      const caption = req.query.caption as string || '';
      
      console.log(`Clip download requested with params:`, {
        clipId, sourceVideo, startTime, endTime, format, caption
      });
      
      // Handle source URL - convert from URL to filesystem path if needed
      if (sourceVideo) {
        // If source is a URL, we need to find the corresponding file
        if (sourceVideo.startsWith('http')) {
          console.log("Source is a URL, attempting to find the actual file");
          
          try {
            // Extract paths from URL
            const urlObj = new URL(sourceVideo);
            const urlPath = urlObj.pathname;
            
            if (urlPath.startsWith('/uploads')) {
              // This is an uploaded file in our uploads directory
              sourceVideo = path.join(process.cwd(), 'public', urlPath);
              console.log(`Mapped URL to filesystem path: ${sourceVideo}`);
            } else if (urlPath.startsWith('/processed-clips')) {
              // This is a processed clip
              sourceVideo = path.join(process.cwd(), 'public', urlPath);
              console.log(`Using existing processed clip: ${sourceVideo}`);
            } else {
              // Try to find the file by looking for the filename part
              const filename = path.basename(urlPath);
              if (filename) {
                // Search in uploads directory for any file matching this name
                const uploadsDir = path.join(process.cwd(), 'public', 'uploads');
                if (fs.existsSync(uploadsDir)) {
                  const files = fs.readdirSync(uploadsDir);
                  const match = files.find(file => file.includes(filename));
                  if (match) {
                    sourceVideo = path.join(uploadsDir, match);
                    console.log(`Found matching file in uploads: ${sourceVideo}`);
                  }
                }
              }
            }
          } catch (urlError) {
            console.error("Error parsing URL:", urlError);
          }
        }
      }
      
      // Search for clip in uploaded videos if no exact path given
      if (!sourceVideo || !fs.existsSync(sourceVideo)) {
        console.log("Source video not found directly, searching uploads directory...");
        
        // Try to find a video in the uploads directory
        const uploadsDir = path.join(process.cwd(), 'public', 'uploads');
        if (fs.existsSync(uploadsDir)) {
          const uploadedFiles = fs.readdirSync(uploadsDir);
          const videoFiles = uploadedFiles.filter(file => 
            file.endsWith('.mp4') || file.endsWith('.mov') || file.endsWith('.webm')
          );
          
          if (videoFiles.length > 0) {
            // Use the most recent uploaded video (sorted by modified time)
            const videoStats = videoFiles.map(file => ({
              file,
              mtime: fs.statSync(path.join(uploadsDir, file)).mtime
            }));
            
            videoStats.sort((a, b) => b.mtime.getTime() - a.mtime.getTime());
            sourceVideo = path.join(uploadsDir, videoStats[0].file);
            console.log(`Using most recent uploaded video: ${sourceVideo}`);
          }
        }
      }
      
      if (sourceVideo && fs.existsSync(sourceVideo)) {
        console.log(`Attempting on-the-fly clip extraction from: ${sourceVideo}`);
        console.log(`With parameters: start=${startTime}, end=${endTime}, format=${format}, caption=${caption}`);
        
        try {
          // Generate a unique filename
          const outputFilename = `reel_${Date.now()}_${clipId}.mp4`;
          
          // Process the clip - force vertical format as requested
          const result = await extractClip(sourceVideo, {
            startTime,
            endTime,
            format: 'vertical', // Always force vertical for downloads
            caption,
            fileName: outputFilename,
            quality: 'high',
            cropPosition: 'center'
          });
          
          if (result.success && result.outputPath) {
            // The outputPath from extractClip is a public URL path, convert to filesystem path
            const filePath = path.join(process.cwd(), 'public', result.outputPath);
            console.log(`Successfully extracted clip on-the-fly: ${filePath}`);
            
            // Set download filename
            const downloadName = `jesko_reel_${clipId}_${startTime}_${endTime}.mp4`;
            return res.download(filePath, downloadName);
          } else {
            console.error("Failed to extract clip on-the-fly:", result.error);
            return res.status(500).json({ error: `Failed to extract clip: ${result.error}` });
          }
        } catch (extractError) {
          console.error("Error during on-the-fly clip extraction:", extractError);
          return res.status(500).json({ error: "Error processing clip extraction" });
        }
      } else {
        console.error(`No source video found for clip: ${clipId}`);
        return res.status(404).json({ 
          error: "Source video not found",
          clipId,
          details: "Could not locate the source video file for extraction"
        });
      }
      
      // If we get here, no clip was found or could be created
      console.error(`No clip found for ID: ${clipId}`);
      return res.status(404).json({
        error: "Clip not found",
        clipId,
        details: "Could not find or extract the requested clip"
      });
    } catch (error: any) {
      console.error("Error processing clip download request:", error);
      res.status(500).json({
        error: "Server error during clip download",
        details: error.message || "Unknown server error"
      });
    }
  });

  // AI Video Magic - Image to Video transformation endpoint (accessible without login)
  app.post('/api/image-to-video', uploadSingleImage, async (req, res) => {
    try {
      // Set simulation mode to false to use the real Runway API
      const SIMULATION_MODE = false; // Attempt to use the real Runway API
      
      // Check if image file was uploaded
      if (!req.file) {
        return res.status(400).json({ error: 'No image file uploaded' });
      }
      
      // Log the uploaded file information
      console.log('Uploaded file:', {
        filename: req.file.filename,
        originalname: req.file.originalname,
        path: req.file.path,
        size: req.file.size,
        mimetype: req.file.mimetype
      });
      
      // Check prompt parameter and other parameters
      const { 
        prompt, 
        modelVersion, 
        negativePrompt, 
        numFrames, 
        numSteps, 
        motionScale,
        guidance,
        timeScale,
        seed,
        aspectRatio
      } = req.body;
      
      console.log('Request body:', { 
        prompt, 
        modelVersion, 
        negativePrompt, 
        numFrames, 
        numSteps,
        motionScale,
        guidance,
        timeScale,
        seed,
        aspectRatio
      });
      
      if (!prompt || typeof prompt !== 'string') {
        return res.status(400).json({ error: 'Invalid request. Required field: prompt' });
      }
      
      // Check if prompt is too short
      if (prompt.trim().length < 3) {
        return res.status(400).json({ error: 'Prompt is too short. Please provide a more detailed description.' });
      }
      
      // The cost for image-to-video transformation is 15 coins per transformation
      const coinCost = 15;
      
      // Get user if authenticated (optional)
      const user = (req as any).user;
      
      // Get the original image file path
      const imagePath = req.file.path;
      
      // Verify the uploaded file exists and is readable
      try {
        await fs.promises.access(imagePath, fs.constants.R_OK);
        const stats = await fs.promises.stat(imagePath);
        console.log(`Image file verified: ${imagePath} (${stats.size} bytes)`);
      } catch (fileError) {
        console.error('Error accessing uploaded file:', fileError);
        return res.status(500).json({ error: 'Unable to access uploaded file' });
      }
      
      // Create a unique filename for the output video
      const outputFilename = `runway-video-${Date.now()}.mp4`;
      const outputPath = path.join(process.cwd(), 'temp', outputFilename);
      
      // Ensure temp directory exists
      if (!fs.existsSync(path.join(process.cwd(), 'temp'))) {
        fs.mkdirSync(path.join(process.cwd(), 'temp'), { recursive: true });
      }
      
      // Handle user coins for authenticated users (deduct coins if available)
      if (user) {
        await logMessage(LogLevel.INFO, 'Coins', `User ${user.email} is using ${coinCost} coins for Runway image-to-video transformation`);
      } else {
        await logMessage(LogLevel.INFO, 'API', 'Anonymous user accessing Runway image-to-video transformation feature');
      }
      
      // Import the new Runway SDK integration module
      // This implementation uses the official SDK to handle API versioning
      const { generateVideoFromImage } = await import('./lib/runway-sdk-integration');
      
      // Process the optional parameters
      const parsedNumFrames = numFrames ? parseInt(numFrames as string) : undefined;
      const parsedNumSteps = numSteps ? parseInt(numSteps as string) : undefined;
      const parsedMotionScale = motionScale ? parseFloat(motionScale as string) : undefined;
      const parsedGuidance = guidance ? parseFloat(guidance as string) : undefined;
      const parsedTimeScale = timeScale ? parseFloat(timeScale as string) : undefined;
      const parsedSeed = seed ? parseInt(seed as string) : undefined;
      
      // Map the old model version names to new SDK model versions
      let sdkModelVersion = 'gen4_turbo';
      if (modelVersion === 'gen-1') {
        sdkModelVersion = 'gen3a_turbo';
      }
      
      // Map UI aspect ratios to SDK-compatible ratios
      let sdkRatio: '1280:720' | '720:1280' | '1104:832' | '832:1104' | '960:960' | '1584:672' = '1280:720';
      
      // Map UI aspect ratios to SDK aspect ratios
      // The Runway API allows only these ratios: 1280:720, 720:1280, 1104:832, 832:1104, 960:960, 1584:672
      switch(aspectRatio) {
        case '16:9':
          sdkRatio = '1280:720'; // 16:9 widescreen
          break;
        case '9:16':
          sdkRatio = '720:1280'; // 9:16 vertical video
          break;
        case '4:3':
          sdkRatio = '1104:832'; // Close to 4:3 (1.33:1 vs 1.327:1)
          break;
        case '3:4':
          sdkRatio = '832:1104'; // Close to 3:4 (0.753:1 vs 0.75:1)
          break;
        case '1:1':
          sdkRatio = '960:960'; // Perfect square
          break;
        case '21:9':
          sdkRatio = '1584:672'; // Ultra widescreen
          break;
        default:
          sdkRatio = '1280:720'; // Default to 16:9 if no matching ratio
      }
      
      console.log(`Using aspect ratio: UI=${aspectRatio}, SDK=${sdkRatio}`);
      
      // Set options for the video generation with the SDK parameters
      const options = {
        modelVersion: sdkModelVersion as 'gen4_turbo' | 'gen3a_turbo',
        negativePrompt: negativePrompt as string,
        ratio: sdkRatio, // Use mapped ratio from user selection
        duration: 5 as const, // Default duration in seconds (must be 5 or 10)
        seed: parsedSeed
      };
      
      console.log('Starting video generation with Runway API using options:', options);
      
      try {
        // Call the Runway API directly to generate a video from the image
        console.log('Calling Runway API directly to transform image to video');
        
        // Initialize result variable
        let result = await generateVideoFromImage(
          imagePath,
          prompt,
          outputPath,
          options
        );
        
        console.log('Runway API result:', result);
        
        if (!result.success) {
          throw new Error(result.error || 'Failed to generate video from image');
        }
        
        // Verify the output file exists and has content
        const outputFileExists = fs.existsSync(outputPath);
        const outputFileSize = outputFileExists ? fs.statSync(outputPath).size : 0;
        
        console.log(`Output file verification: exists=${outputFileExists}, size=${outputFileSize} bytes`);
        
        if (!outputFileExists || outputFileSize === 0) {
          throw new Error('Generated video file is missing or empty');
        }
        
        // Also add the video to the stock_videos table as an AI-generated video
        try {
          // Generate a title from the prompt (use first 50 chars or less)
          const videoTitle = prompt.length > 50 
            ? prompt.substring(0, 47) + '...' 
            : prompt;
          
          // Create a permanent copy of the video in the uploads directory
          const uploadDir = path.join(process.cwd(), 'uploads');
          if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
          }
          
          // Create a unique filename for the permanent storage
          const permanentFilename = `ai-video-${Date.now()}-${uuidv4()}.mp4`;
          const permanentPath = path.join(uploadDir, permanentFilename);
          
          // Copy the file to the uploads directory
          fs.copyFileSync(outputPath, permanentPath);
          
          // Extract a thumbnail from the video (for now using a placeholder)
          // In a real implementation, we would extract a frame from the video
          let thumbnailUrl = '/images/default-thumbnail.jpg';
          
          // If we have the original image, use it as the thumbnail
          if (fs.existsSync(imagePath)) {
            // Temporarily use the original image as thumbnail
            thumbnailUrl = imagePath.replace(process.cwd(), '');
          }
          
          try {
            // Check for duplicate videos with the same prompt and model
            const existingVideos = await db
              .select()
              .from(stockVideos)
              .where(sql`LOWER(${stockVideos.promptUsed}) = LOWER(${prompt})`)
              .where(sql`${stockVideos.modelUsed} = ${options.modelVersion as string}`)
              .limit(1);
              
            let videoRecord;
            
            // If similar video already exists, use that instead of creating a duplicate
            if (existingVideos.length > 0) {
              console.log('Found existing video with same prompt and model. Preventing duplicate.');
              videoRecord = existingVideos[0];
              console.log('Using existing video instead:', videoRecord);
            } else {
              // Save to stock_videos table if no duplicate was found
              const [newVideo] = await db
                .insert(stockVideos)
                .values({
                  title: videoTitle,
                  description: `AI-generated video using prompt: ${prompt}`,
                  videoUrl: `/uploads/${permanentFilename}`,
                  thumbnailUrl,
                  duration: result.duration || 5,
                  aspectRatio: aspectRatio || '16:9',
                  category: 'AI Generated',
                  tags: ['ai', 'runway', options.modelVersion as string, 'video-magic'],
                  userId: user ? user.id : null,
                  isAIGenerated: true,
                  promptUsed: prompt,
                  sourceImageUrl: imagePath.replace(process.cwd(), ''),
                  modelUsed: options.modelVersion as string
                })
                .returning();
              
              videoRecord = newVideo;
              console.log('Added video to stock_videos:', videoRecord);
            }
          } catch (stockVideoError) {
            // Log the error but don't fail the request
            console.error('Error adding to stock_videos table:', stockVideoError);
            // We'll continue and return the video even if saving to stock_videos fails
          }
        
        // Return success response with video URL
        res.json({ 
          success: true, 
          videoUrl: `/temp/${outputFilename}`,
          promptUsed: prompt,
          modelVersion: options.modelVersion,
          aspectRatio: aspectRatio || '16:9',
          numFrames: parsedNumFrames || 'default',
          duration: result.duration,
          message: `Successfully generated video from image using Runway ${options.modelVersion}`
        });
      } catch (error) {
        console.error('Error calling Runway API:', error);
        
        // If user is authenticated, we would refund the coins here
        if (user) {
          await logMessage(LogLevel.INFO, 'API', `Would refund ${coinCost} coins to user ${user.email} due to transformation failure`);
        }
        
        throw new Error(`Runway API error: ${error instanceof Error ? error.message : String(error)}`);
      }
    } catch (error) {
      console.error('Error in image-to-video endpoint:', error);
        
      // Create a more user-friendly message for specific error types
      let userMessage = "Server error during image-to-video transformation";
      const errorMsg = error instanceof Error ? error.message : String(error);
      
      // Special handling for API version issues
      if (errorMsg.includes('API version') || errorMsg.includes('version header')) {
        userMessage = "We're experiencing technical issues with the video generation API. Our team has been notified and is working on a fix.";
      } else if (errorMsg.includes('credit') || errorMsg.includes('quota')) {
        userMessage = "The API service has reached its quota limit. Please try again later.";
      }
      
      res.status(500).json({ 
        error: userMessage,
        details: errorMsg
      });
    }
  });
  
  // AI Video Magic - Video transformation endpoint (accessible without login)
  // Get models for AI Video Magic
  app.get('/api/runway/models', async (req, res) => {
    try {
      // Import the new Runway SDK integration module
      const { getAvailableModels } = await import('./lib/runway-sdk-integration');
      
      // Get available models from Runway API
      const result = await getAvailableModels();
      
      // Return a list of supported models
      if (result.success && result.models) {
        res.json({
          success: true,
          models: result.models
        });
      } else {
        throw new Error(result.error || 'Unknown error getting models');
      }
    } catch (error) {
      console.error('Error fetching Runway models:', error);
      res.status(500).json({ error: "Failed to fetch Runway models" });
    }
  });
  
  // AI Video Magic - Image interpolation endpoint for creating smooth transitions between multiple images
  // Configure multer for multiple image uploads
  const uploadMultipleImages = multer({
    storage: multer.diskStorage({
      destination: function (req, file, cb) {
        const uploadDir = path.join(process.cwd(), 'uploads');
        if (!fs.existsSync(uploadDir)) {
          fs.mkdirSync(uploadDir, { recursive: true });
        }
        cb(null, uploadDir);
      },
      filename: function (req, file, cb) {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        const fileExt = path.extname(file.originalname);
        cb(null, file.fieldname + '-' + uniqueSuffix + fileExt);
      }
    }),
    limits: {
      fileSize: 10 * 1024 * 1024, // 10MB file size limit
    },
    fileFilter: function (req, file, cb) {
      // Accept images only
      if (!file.originalname.match(/\.(jpg|jpeg|png|gif|webp)$/)) {
        return cb(new Error('Only image files are allowed!'), false);
      }
      cb(null, true);
    }
  });
  
  app.post('/api/runway/interpolate', uploadMultipleImages.array('images', 10), async (req, res) => {
    try {
      // Check if images were uploaded
      if (!req.files || req.files.length < 2) {
        return res.status(400).json({ 
          error: 'At least two images are required for interpolation',
          details: `Received ${req.files ? req.files.length : 0} images`
        });
      }
      
      // Log the uploaded files information
      console.log('Uploaded files:', req.files.map(file => ({
        filename: file.filename,
        originalname: file.originalname,
        path: file.path,
        size: file.size,
        mimetype: file.mimetype
      })));
      
      // Check parameters
      const { mode, fps, margin } = req.body;
      
      console.log('Request body:', { mode, fps, margin });
      
      // The cost for image interpolation is 20 coins per transformation (higher than single image)
      const coinCost = 20;
      
      // Get user if authenticated (optional)
      const user = (req as any).user;
      
      // Get the image file paths
      const imagePaths = (req.files as Express.Multer.File[]).map(file => file.path);
      
      // Create a unique filename for the output video
      const outputFilename = `runway-interpolate-${Date.now()}.mp4`;
      const outputPath = path.join(process.cwd(), 'temp', outputFilename);
      
      // Ensure temp directory exists
      if (!fs.existsSync(path.join(process.cwd(), 'temp'))) {
        fs.mkdirSync(path.join(process.cwd(), 'temp'), { recursive: true });
      }
      
      // Handle user coins for authenticated users (deduct coins if available)
      if (user) {
        await logMessage(LogLevel.INFO, 'Coins', `User ${user.email} is using ${coinCost} coins for Runway image interpolation`);
      } else {
        await logMessage(LogLevel.INFO, 'API', 'Anonymous user accessing Runway image interpolation feature');
      }
      
      // Import the new Runway SDK integration module
      const { interpolateImages } = await import('./lib/runway-sdk-integration');
      
      // Process the optional parameters
      const parsedFps = fps ? parseInt(fps as string) : 30;
      const parsedMargin = margin ? parseInt(margin as string) : 0;
      
      // Set options for the video generation
      const options = {
        mode: (mode || 'standard') as 'standard' | 'linear' | 'cubic',
        fps: parsedFps,
        margin: parsedMargin
      };
      
      console.log('Starting image interpolation with Runway API using options:', options);
      
      try {
        // Call the Runway API to generate a video from the images
        const result = await interpolateImages(
          imagePaths,
          outputPath,
          options
        );
        
        console.log('Runway API result:', result);
        
        if (!result.success) {
          throw new Error(result.error || 'Failed to generate interpolated video from images');
        }
        
        // Verify the output file exists and has content
        const outputFileExists = fs.existsSync(outputPath);
        const outputFileSize = outputFileExists ? fs.statSync(outputPath).size : 0;
        
        console.log(`Output file verification: exists=${outputFileExists}, size=${outputFileSize} bytes`);
        
        if (!outputFileExists || outputFileSize === 0) {
          throw new Error('Generated video file is missing or empty');
        }
        
        // Return success response with video URL
        res.json({ 
          success: true, 
          videoUrl: `/temp/${outputFilename}`,
          numImages: imagePaths.length,
          mode: options.mode,
          fps: options.fps,
          duration: result.duration,
          message: `Successfully generated interpolated video from ${imagePaths.length} images using Runway`
        });
      } catch (error) {
        console.error('Error calling Runway API for image interpolation:', error);
        
        // If user is authenticated, we would refund the coins here
        if (user) {
          await logMessage(LogLevel.INFO, 'API', `Would refund ${coinCost} coins to user ${user.email} due to interpolation failure`);
        }
        
        throw new Error(`Runway API error: ${error instanceof Error ? error.message : String(error)}`);
      }
    } catch (error) {
      console.error('Error in image interpolation endpoint:', error);
      res.status(500).json({ 
        error: "Server error during image interpolation",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  
  app.post('/api/transform-video', uploadSingleVideo, async (req, res) => {
    try {
      // Check if video file was uploaded
      if (!req.file) {
        return res.status(400).json({ error: 'No video file uploaded' });
      }
      
      // Check prompt parameter
      const { prompt } = req.body;
      
      if (!prompt || typeof prompt !== 'string') {
        return res.status(400).json({ error: 'Invalid request. Required field: prompt' });
      }
      
      // Check if prompt is too short
      if (prompt.trim().length < 3) {
        return res.status(400).json({ error: 'Prompt is too short. Please provide a more detailed description.' });
      }
      
      // The cost for video transformation is 15 coins per video for logged-in users
      const coinCost = 15;
      
      // Get user if authenticated (optional)
      const user = (req as any).user;
      
      // Get the original video file path
      const videoPath = req.file.path;
      
      // Create a unique filename for the output video based on the original filename
      const outputFilename = `transformed-${Date.now()}-${path.basename(videoPath)}`;
      const outputPath = path.join(process.cwd(), 'temp', outputFilename);
      
      // For demonstration purposes, if the user is logged in, we would deduct coins
      // Here we'll simply log the intention since this is a demo feature
      if (user) {
        await logMessage(LogLevel.INFO, 'Coins', `If implemented, user ${user.email} would use ${coinCost} coins for video transformation`);
      } else {
        await logMessage(LogLevel.INFO, 'API', 'Anonymous user accessing video transformation feature');
      }
      
      try {
        // Create a proper form data object for Node.js using form-data package
        const formData = new FormData();
        // Use the actual video file as a stream
        const fileStream = fs.createReadStream(videoPath);
        formData.append('video', fileStream, {
          filename: path.basename(videoPath),
          contentType: 'video/mp4'
        });
        formData.append('prompt', prompt);
        
        // Use the Spike Studio API key from environment variables if available
        const apiKey = process.env.SPIKE_API_KEY || 'your_spike_api_key';
        console.log("Using API key for video transformation:", apiKey ? "API key found" : "Default key");
        
        // Call the external API to transform the video
        const apiResponse = await axios.post(
          'https://api.spikestudio.ai/v1/transform',
          formData,
          {
            headers: {
              ...formData.getHeaders(),
              'Authorization': `Bearer ${apiKey}`
            },
            responseType: 'stream'
          }
        );
        
        // Write the response to the output file
        const writer = fs.createWriteStream(outputPath);
        apiResponse.data.pipe(writer);
        
        // Return a promise that resolves when the file is written
        await new Promise((resolve, reject) => {
          writer.on('finish', resolve);
          writer.on('error', reject);
        });
        
        // Return success response with video URL
        res.json({ 
          success: true, 
          videoUrl: `/temp/${outputFilename}`,
          promptUsed: prompt,
          message: `Successfully transformed video`
        });
      } catch (error) {
        console.error('Error calling external API:', error);
        
        // If user is authenticated, we would refund the coins here
        if (user) {
          await logMessage(LogLevel.INFO, 'API', `If implemented, would refund ${coinCost} coins to user ${user.email} due to transformation failure`);
        }
        
        throw new Error(`External API error: ${error instanceof Error ? error.message : String(error)}`);
      }
    } catch (error) {
      console.error("Error processing video transformation request:", error);
      await logMessage(LogLevel.ERROR, 'API', `Error processing video transformation request: ${error instanceof Error ? error.message : String(error)}`);
      res.status(500).json({ error: "Failed to process video transformation request", details: error instanceof Error ? error.message : String(error) });
    }
  });

  return httpServer;
}

// Utility functions
function generateId() {
  return Math.random().toString(36).substring(2, 10);
}

function broadcastToAll(data: any) {
  const message = JSON.stringify(data);
  
  clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  });
}

function sendServerStatus(ws: WebSocket) {
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: 'server_status',
      payload: {
        online: true,
        message: 'Server Online'
      }
    }));
  }
}

async function logMessage(level: LogLevel, source: string, message: string) {
  console.log(`[${level}] [${source}] ${message}`);
  
  try {
    await storage.addLog({
      level,
      source,
      message
    });
  } catch (error) {
    console.error('Error storing log:', error);
  }
}

function calculateUptime() {
  const uptime = new Date().getTime() - startTime.getTime();
  const days = Math.floor(uptime / (24 * 60 * 60 * 1000));
  const hours = Math.floor((uptime % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
  const minutes = Math.floor((uptime % (60 * 60 * 1000)) / (60 * 1000));
  
  return `${days}d ${hours}h ${minutes}m`;
}

async function checkServiceStatus(service: string): Promise<boolean> {
  try {
    const config = await storage.getConfig();
    
    switch (service) {
      case 'phone':
      case 'phonenumber':
      case 'twilio':
        return !!config.twilioAccountSid;
      case 'brain':
      case 'aibrain':
      case 'openai':
        return !!config.openaiApiKey;
      case 'voice':
      case 'aivoice':
      case 'elevenlabs':
        return !!config.elevenLabsApiKey;
      default:
        return false;
    }
  } catch (error) {
    console.error(`Error checking service status for ${service}:`, error);
    return false;
  }
}

async function getElevenLabsVoices() {
  try {
    const config = await storage.getConfig();
    console.log('Getting ElevenLabs voices, API key in config:', !!config.elevenLabsApiKey);
    
    // Try to use environment variable as a fallback
    const apiKey = config.elevenLabsApiKey || process.env.ELEVENLABS_API_KEY;
    console.log('Final API key status (from config or env):', !!apiKey);
    
    if (!apiKey) {
      console.log('No ElevenLabs API key found, attempting to fetch public voices');
      try {
        // Fetch public voices from ElevenLabs API even without an API key
        console.log('Making request to ElevenLabs public API');
        const response = await axios.get('https://api.elevenlabs.io/v1/voices');
        console.log('Successfully received ElevenLabs voices:', response.data.voices.length);
        
        return response.data.voices.map((voice: any) => ({
          voice_id: voice.voice_id, // Make sure we use voice_id consistently across the app
          name: voice.name,
          description: voice.labels ? 
            `${voice.labels.gender || ''}, ${voice.labels.accent || ''}${voice.labels.description ? ', ' + voice.labels.description : ''}`.trim() 
            : 'Voice',
          preview_url: voice.preview_url,
          labels: voice.labels
        }));
      } catch (publicError) {
        console.error('Error fetching public ElevenLabs voices:', publicError);
        // Fall back to sample voices with preview URLs if public API fails
        return [
          { 
            voice_id: "sample", 
            name: "Rachel", 
            description: "Female, US", 
            preview_url: "https://media.elevenlabs.io/sample-voice-previews/female-us.mp3" 
          },
          { 
            voice_id: "sample2", 
            name: "Adam", 
            description: "Male, UK", 
            preview_url: "https://media.elevenlabs.io/sample-voice-previews/male-uk.mp3" 
          },
          { 
            voice_id: "sample3", 
            name: "Sarah", 
            description: "Female, AU", 
            preview_url: "https://media.elevenlabs.io/sample-voice-previews/female-au.mp3" 
          },
          { 
            voice_id: "sample4", 
            name: "Michael", 
            description: "Male, US",
            preview_url: "https://media.elevenlabs.io/sample-voice-previews/male-us.mp3" 
          }
        ];
      }
    }
    
    // When API key is provided, use authenticated request
    const response = await axios.get('https://api.elevenlabs.io/v1/voices', {
      headers: {
        'xi-api-key': config.elevenLabsApiKey
      }
    });
    
    return response.data.voices.map((voice: any) => ({
      voice_id: voice.voice_id,
      name: voice.name,
      description: voice.labels ? 
        `${voice.labels.gender || ''}, ${voice.labels.accent || ''}${voice.labels.description ? ', ' + voice.labels.description : ''}`.trim() 
        : 'Custom voice',
      preview_url: voice.preview_url
    }));
  } catch (error) {
    console.error('Error fetching ElevenLabs voices:', error);
    throw error;
  }
}

async function getElevenLabsModels() {
  try {
    const config = await storage.getConfig();
    
    if (!config.elevenLabsApiKey) {
      return [
        { model_id: "eleven_monolingual_v1", name: "Monolingual v1", token_cost_factor: 1 },
        { model_id: "eleven_multilingual_v1", name: "Multilingual v1", token_cost_factor: 1.5 },
        { model_id: "eleven_multilingual_v2", name: "Multilingual v2", token_cost_factor: 2 }
      ];
    }
    
    const response = await axios.get('https://api.elevenlabs.io/v1/models', {
      headers: {
        'xi-api-key': config.elevenLabsApiKey
      }
    });
    
    return response.data.map((model: any) => ({
      model_id: model.model_id,
      name: model.name,
      token_cost_factor: model.token_cost_factor
    }));
  } catch (error) {
    console.error('Error fetching ElevenLabs models:', error);
    return [
      { model_id: "eleven_monolingual_v1", name: "Monolingual v1", token_cost_factor: 1 },
      { model_id: "eleven_multilingual_v1", name: "Multilingual v1", token_cost_factor: 1.5 },
      { model_id: "eleven_multilingual_v2", name: "Multilingual v2", token_cost_factor: 2 }
    ];
  }
}

